[{"id":0,"href":"/docs/algorithm/","title":"Algorithm","section":"Docs","content":" 000 Sample "},{"id":1,"href":"/docs/batch/","title":"Batch","section":"Docs","content":" 000 Sample "},{"id":2,"href":"/docs/data-structure/","title":"Data Structure","section":"Docs","content":" 000 Sample "},{"id":3,"href":"/docs/ddd/","title":"Ddd","section":"Docs","content":" 000 Sample "},{"id":4,"href":"/docs/docker/","title":"Docker","section":"Docs","content":" 000 Sample "},{"id":5,"href":"/docs/etc/","title":"Etc","section":"Docs","content":" 000 Sample "},{"id":6,"href":"/docs/java/","title":"Java","section":"Docs","content":" 000 Sample "},{"id":7,"href":"/docs/jenkins/","title":"Jenkins","section":"Docs","content":" 000 Sample "},{"id":8,"href":"/docs/jpa/","title":"Jpa","section":"Docs","content":" 000 Sample "},{"id":9,"href":"/docs/kafka/","title":"Kafka","section":"Docs","content":" 000 Sample "},{"id":10,"href":"/docs/kotlin/","title":"Kotlin","section":"Docs","content":" 004 Kotlin Scoping Functions 003 Kotlin Basic 002 Functional Programming Example 001 Functional Programming "},{"id":11,"href":"/docs/linux/","title":"Linux","section":"Docs","content":" 000 Sample "},{"id":12,"href":"/docs/mongodb/","title":"Mongodb","section":"Docs","content":" 000 Sample "},{"id":13,"href":"/docs/msa/","title":"Msa","section":"Docs","content":" 000 Sample "},{"id":14,"href":"/docs/mvc/","title":"Mvc","section":"Docs","content":" 000 Sample "},{"id":15,"href":"/docs/mysql/","title":"Mysql","section":"Docs","content":" 000 Sample "},{"id":16,"href":"/docs/network/","title":"Network","section":"Docs","content":" 000 Sample "},{"id":17,"href":"/docs/operating-system/","title":"Operating System","section":"Docs","content":" 000 Sample "},{"id":18,"href":"/docs/oracle/","title":"Oracle","section":"Docs","content":" 000 Sample "},{"id":19,"href":"/docs/reactive-streams/","title":"Reactive Streams","section":"Docs","content":" 002 Impl1 Reactor 003 Impl2 Rxjava 004 Impl3 Munity 001 Reactive Streams Component "},{"id":20,"href":"/docs/redis/","title":"Redis","section":"Docs","content":" 001 Redis Datastructure 002 Redis Cache "},{"id":21,"href":"/docs/security/","title":"Security","section":"Docs","content":" 000 Sample "},{"id":22,"href":"/docs/servlet/","title":"Servlet","section":"Docs","content":" 000 Sample "},{"id":23,"href":"/docs/spring/","title":"Spring","section":"Docs","content":" 000 Sample "},{"id":24,"href":"/docs/test/","title":"Test","section":"Docs","content":" 000 Sample "},{"id":25,"href":"/docs/webflux/","title":"Webflux","section":"Docs","content":" 000 Sample "},{"id":26,"href":"/docs/kotlin/004_Kotlin_Scoping_Functions/","title":"004 Kotlin Scoping Functions","section":"Kotlin","content":" Kotlin Scoping Functions apply vs. with, let, also, and run # apply, with, let, also, run # Kotlin의 Receiver # 객체 외부의 람다 코드 블록을 마치 해당 객체 내부에서 사용하는 것 처럼 작성할 수 있게 해주는 장치\nblock : T.() -\u0026gt; R 위 람다 블록은 객체 T를 receiver로 이용하여 객체 R을 반환한다.\nreceiver : 객체 T receiver를 사용하는 람다 : lambda with receiver block : (T) -\u0026gt; R 위의 경우 객체 T를 리시버가 아니라 람다 파라미터로 받는다.\n범위 지정 함수란? # 수신객체 수신객체 지정 람다 (lambda with receiver) 람다 식 내에서 수신 객체의 멤버에 직접 접근할 수 있게 하는 기능 with # inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { return receiver.block() } 수신객체 : receiver T 수신 객체 지정 람다 : block Before\nclass Person { var name: String? = null var age: Int? = null } val person: Person = getPerson() print(person.name) print(person.age) After\nval person: Person = getPerson() with(person) { print(name) print(age) } also # inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } T 의 확장함수로 수신 객체가 암시적으로 제공 수신 객체 지정 람다 : 매개변수 T 로 코드 블록 내에 명시적으로 전달 Before\nclass Person { var name: String? = null var age: Int? = null } val person: Person = getPerson() print(person.name) print(person.age) After\nval person: Person = getPerson().also { print(it.name) print(it.age) } with, also, apply, let, run 차이점 # 호출시에 수신 객체가 매개 변수로 명시적으로 전달되거나 수신 객체의 확장 함수로 암시적 수신 객체 로 전달 수신 객체 지정 람다 에 전달되는 수신 객체가 명시적 매개 변수 로 전달 되거나 수신 객체의 확장 함수로 암시적 수신 객체로 코드 블록 내부로 전달 범위 지정 함수의 결과로 수신 객체를 그대로 반환하거나 수신 객체 지정 람다 의 실행 결과를 반환 inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { return receiver.block() } inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { block() return this } inline fun \u0026lt;T, R\u0026gt; T.let(block: (T) -\u0026gt; R): R { return block(this) } inline fun \u0026lt;T, R\u0026gt; T.run(block: T.() -\u0026gt; R): R { return block() } apply 사용 규칙 # 수신 객체 람다 내부에서 수신 객체의 함수를 사용하지 않고 수신 객체 자신을 다시 반환 하려는 경우 Before\nval clark = Person() clark.name = \u0026#34;Clark\u0026#34; clark.age = 18 After\nval peter = Person().apply { // apply 의 블록 에서는 오직 프로퍼티 만 사용합니다! name = \u0026#34;Peter\u0026#34; age = 18 } also 사용 규칙 # 수신 객체 람다가 전달된 수신 객체를 전혀 사용 하지 않거나 수신 객체의 속성을 변경하지 않고 사용하는 경우 수신 객체를 반환 하므로 블록 함수가 다른 값을 반환 해야하는 경우 사용 불가능 inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } Before\nclass Book(val author: Person) { init { requireNotNull(author.age) print(author.name) } } After\nclass Book(author: Person) { val author = author.also { requireNotNull(it.age) print(it.name) } } apply 와 also : 리시버와 파라미터의 차이 # public inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } public inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { block() return this } also : 객체를 람다 파라미터로 받는다. apply : 객체를 리시버로 받는다. class person { var name = \u0026#34;kotlin\u0026#34; private val id = \u0026#34;1541\u0026#34; } person.also { println(\u0026#34;my name is ${it.name}\u0026#34;) } person.apply { println(\u0026#34;my name is $name\u0026#34;) } also : it을 사용한다. apply : this를 사용한다. it vs this # 내가 작성하고자 하는 코드의 의미(semantics) 에 따라 also를 쓸지 apply를 쓸지 결정하는 것이다.\nit also는 객체를 람다 아규먼트로 받기 때문에 객체에 접근할 때 it(혹은 내가 정의한 다른 이름)을 사용 이는 코드가 객체 외부에서 해당 객체에 접근한다는 인상을 강하게 준다. 객체를 외부에서 접근하는 느낌을 주기 때문에 해당 객체와 더불어(혹은 이용해서) 어떠한 행위를 수행하고자 할 때 쓰인다. person.also { println(\u0026#34;my name is ${it.steven}\u0026#34;) } this apply 는 객체를 람다 리시버로 받기 때문에 객체에 접근할 때 this(혹은 생략)을 사용 코드가 해당 객체의 외부가 아니라 객체 내부에 있는듯한 인상을 준다. apply코드 블록이 객체 내부에 있는 듯한 느낌을 주기 때문에 주로 객체를 초기화 하는 코드 혹은 객체의 상태를 변경하는 코드에 많이 사용된다. person.apply { name = \u0026#34;steven\u0026#34; age = 21 } let 사용 규칙 # 지정된 값이 null 이 아닌 경우에 코드를 실행해야 하는 경우 Nullable 객체를 다른 Nullable 객체로 변환하는 경우 단일 지역 변수의 범위를 제한 하는 경우 inline fun \u0026lt;T, R\u0026gt; T.let(block: (T) -\u0026gt; R): R { return block(this) } Before\nval person: Person? = getPromotablePerson() if (person != null) { promote(person) } val driver: Person? = getDriver() val driversLicence: Licence? = if (driver == null) null else licenceService.getDriversLicence(it) val person: Person = getPerson() val personDao: PersonDao = getPersonDao() personDao.insert(person) After\ngetNullablePerson()?.let { // null 이 아닐때만 실행됩니다. promote(it) } val driversLicence: Licence? = getNullablePerson()?.let { // nullable personal객체를 nullable driversLicence 객체로 변경합니다. licenceService.getDriversLicence(it) } val person: Person = getPerson() getPersonDao().let { dao -\u0026gt; // 변수 dao 의 범위는 이 블록 안 으로 제한 됩니다. dao.insert(person) } with 사용 규칙 # Non-nullable (Null 이 될수 없는) 수신 객체 이고 결과가 필요하지 않은 경우에만 with 를 사용 inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { return receiver.block() } Before\nval person: Person = getPerson() print(person.name) print(person.age) After\nval person: Person = getPerson() with(person) { print(name) print(age) } run 사용 규칙 # 어떤 값을 계산할 필요가 있거나 여러개의 지역 변수의 범위를 제한하려면 run 을 사용 매개 변수로 전달된 명시적 수신객체 를 암시적 수신 객체로 변환 할때 run ()을 사용 inline fun \u0026lt;T, R\u0026gt; T.run(block: T.() -\u0026gt; R): R { return block() } Before\nval person: Person = getPerson() val personDao: PersonDao = getPersonDao() val inserted: Boolean = personDao.insert(person) fun printAge(person: Person) = { print(person.age) } After\nval inserted: Boolean = run { // person 과 personDao 의 범위를 제한 합니다. val person: Person = getPerson() val personDao: PersonDao = getPersonDao() // 수행 결과를 반환 합니다. personDao.insert(person) } fun printAge(person: Person) = person.run { // person 을 수신객체로 변환하여 age 값을 사용합니다. print(age) } 여러 범위 지정 함수 결합 # 하나의 코드 블록 내에서 여러 범위 지정 함수를 중첩하지 않는 것이 좋다. 수신객체 지정 람다 에 수신 객체가 암시적으로 전달되는 apply, run, with 는 중첩하지 말라. 이 함수들은 수신 객체를 this 또는 생략하여 사용하며, 수신객체의 이름을 다르게 지정할수 없기 때문에 중첩될 경우 혼동 하기 쉽다. also 와 let 을 중첩 해야만 할때는 암시적 수신 객체 를 가르키는 매개 변수 인 it 을 사용하지 말고, 명시적인 이름을 제공해서 코드상의 이름이 혼동되지 않도록 하자.\nprivate fun insert(user: User) = SqlBuilder().apply { append(\u0026#34;INSERT INTO user (email, name, age) VALUES \u0026#34;) append(\u0026#34;(?\u0026#34;, user.email) append(\u0026#34;,?\u0026#34;, user.name) append(\u0026#34;,?)\u0026#34;, user.age) }.also { print(\u0026#34;Executing SQL update: $it.\u0026#34;) }.run { jdbc.update(this) \u0026gt; 0 } References _1) https://medium.com/@limgyumin/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%98-apply-with-let-also-run-%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-4a517292df29\n_2) https://jaeyeong951.medium.com/kotlin-lambda-with-receiver-5c2cccd8265a "},{"id":27,"href":"/docs/kotlin/003_Kotlin_basic/","title":"003 Kotlin Basic","section":"Kotlin","content":" 코틀린 문법 한번에 정리하기 # 주석 정리 Variable # // top-level var x = 5 fun main() { x+= 1 println(x) val a : Int = 1 val b = 1 val c : Int c = 3 val d : Int d = 123 //val(value) : 불변(Immutable) //var(variable) : 가변(Mutable) var e : String = \u0026#34;Hello\u0026#34; e = \u0026#34;World\u0026#34; var f = 123 // f = \u0026#34;hi\u0026#34; // 컴파일 오류 타입은 변경이 불가 } Function # // 기본적인 함수 선언 스타일 fun sum(a: Int, b: Int) : Int { return a + b } // 표현식 스타일 fun sum2(a: Int, b: Int) : Int = a + b // 표현식 \u0026amp; 반환타입 생략 fun sum3(a: Int, b: Int) = a + b // 몸통이 있는 함수는 반환 타입을 제거하면 컴파일 오류 fun sum4(a: Int, b: Int) : Int { return a + b } // 반환타입이 없는 함수는 Unit을 반환한다 fun printSum(a: Int, b: Int) : Unit { println(\u0026#34;$a + $b = ${a + b}\u0026#34;) } // 디폴트 파라미터 fun greeting(message: String = \u0026#34;안녕하세요!!\u0026#34;) { println(message) } // //fun main( ) { // greeting() // greeting(\u0026#34;HI!!!\u0026#34;) //} fun log(level: String = \u0026#34;INFO\u0026#34;, message: String) { println(\u0026#34;[$level]$message\u0026#34;) } fun main( ) { log(message = \u0026#34;인포 로그\u0026#34;) log(level = \u0026#34;DEBUG\u0026#34;, \u0026#34;디버그 로그\u0026#34;) log(\u0026#34;WARN\u0026#34;, \u0026#34;워닝 로그\u0026#34;) log(level = \u0026#34;ERROR\u0026#34;, message = \u0026#34;에러 로그\u0026#34;) } For # fun main() { // 범위 연산자 .. 를 사용해 for loop 돌리기 for (i in 0..3) { println(i) } // until 을 사용해 반복한다 // 뒤에 온 숫자는 포함하지 않는다 for (i in 0 until 3) { println(i) } // step 에 들어온 값 만큼 증가시킨다 for ( i in 0..6 step 2) { println(i) } // downTo를 사용해 반복하면서 값을 감소시킨다 for (i in 3 downTo 1) { println(i) } // 전달받은 배열을 반복 val numbers = arrayOf(1,2,3) for (i in numbers) { println(i) } } If # fun main() { //if..else 사용 val job = \u0026#34;Software Developer\u0026#34; if (job == \u0026#34;Software Developer\u0026#34;) { println(\u0026#34;개발자\u0026#34;) } else { println(\u0026#34;개발자아님\u0026#34;) } //코틀린의 if...else는 표현식이다 val age : Int = 10 val str = if (age \u0026gt; 10) { \u0026#34;성인\u0026#34; } else { \u0026#34;아이\u0026#34; } //코틀린은 삼항 연산자가 없다. if..else가 표현식이므로 불필요하다 val a = 1 val b = 2 val c = if (b \u0026gt; a) b else a } When # fun main() { // 자바 코드를 코틀린의 when식으로 변환한 코드 val day = 2 val result = when (day) { 1 -\u0026gt; \u0026#34;월요일\u0026#34; 2 -\u0026gt; \u0026#34;화요일\u0026#34; 3 -\u0026gt; \u0026#34;수요일\u0026#34; 4 -\u0026gt; \u0026#34;목요일\u0026#34; else -\u0026gt; \u0026#34;기타\u0026#34; } println(result) // else를 생략할 수 있다 when(getColor()) { Color.RED -\u0026gt; print(\u0026#34;red\u0026#34;) Color.GREEN -\u0026gt; println(\u0026#34;green\u0026#34;) else -\u0026gt; println(\u0026#34;blue\u0026#34;) } // 여러개의 조건을 콤마로 구분해 한줄에서 정의할 수 있다 when (getNumber()) { 0, 1 -\u0026gt; print(\u0026#34;0 또는 1\u0026#34;) else -\u0026gt; print(\u0026#34;0 또는 1이 아님\u0026#34;) } } enum class Color { RED, GREEN, BLUE } fun getColor() = Color.RED fun getNumber() = 2 while # fun main() { // 자바의 while문과 동일 // 조건을 확인하고 참이면 코드 블록을 실행한 후 다시 조건을 확인 var x = 5 while (x \u0026gt; 0) { println(x) x-- } } Exception # fun main() { try { throw Exception() } catch (e: Exception) { println(\u0026#34;에러 발생!\u0026#34;) } finally { println(\u0026#34;finally 실행!\u0026#34;) } val a = try { \u0026#34;1234\u0026#34;.toInt() } catch (e: Exception) { println(\u0026#34;예외 발생 !\u0026#34;) } println(a) //throw Exception(\u0026#34;예외 발생!\u0026#34;) val b: String? = null val c: String = b ?: failFast(\u0026#34;a is null\u0026#34;) println(c.length) } fun failFast(message: String): Nothing { throw IllegalArgumentException(message) } Null Safety # fun getNullStr(): String? = null fun getLengthIfNotNull(str: String?) = str?.length ?: 0 fun main() { val nullableStr = getNullStr() val nullableStrLength = nullableStr?.length ?: \u0026#34;null인 경우 반환\u0026#34;.length println(nullableStrLength) val length = getLengthIfNotNull(null) println(length) //throw NullPointerException() // val c: String? = null // val d = c!!.length // println(Java_NullSafety.getNullStr()?.length ?: 0) } Class Property # class Coffee( var name: String = \u0026#34;\u0026#34;, var price: Int = 0, var iced: Boolean = false, ) { val brand: String get() { return \u0026#34;스타벅스\u0026#34; } var quantity : Int = 0 set(value) { if (value \u0026gt; 0) { // 수량이 0 이상인 경우에만 할당 field = value } } } class EmptyClass fun main() { val coffee = Coffee() coffee.name = \u0026#34;아이스 아메리카노\u0026#34; coffee.price = 2000 coffee.quantity = 1 coffee.iced = true if (coffee.iced) { println(\u0026#34;아이스 커피\u0026#34;) } println(\u0026#34;${coffee.brand} ${coffee.name} 가격은 ${coffee.price} 수량은 ${coffee.quantity}\u0026#34;) } Inheritance # open class Dog { open var age: Int = 0 open fun bark() { // 반드시 오버라이드해야하는건 아니다. open fun일 경우 반드시 body를 구현해야한다. println(\u0026#34;멍멍\u0026#34;) } } open class Bulldog(final override var age: Int = 0) : Dog() { final override fun bark() { super.bark() } } abstract class Developer { abstract var age: Int abstract fun code(language: String) } class BackendDeveloper(override var age : Int) : Developer() { override fun code(language: String) { println(\u0026#34;I code with $language\u0026#34;) } } fun main() { val backendDeveloper = BackendDeveloper(age = 20) println(backendDeveloper.age) backendDeveloper.code(\u0026#34;Kotlin\u0026#34;) val dog = Bulldog(age = 2) println(dog.age) dog.bark() } Interface # class Product(val name: String, val price: Int) interface Wheel { fun roll() } interface Cart : Wheel { var coin: Int val weight: String get() = \u0026#34;20KG\u0026#34; fun add(product: Product) fun rent() { if (coin \u0026gt; 0) { println(\u0026#34;카트를 대여합니다\u0026#34;) } } override fun roll() { println(\u0026#34;카트가 굴러갑니다\u0026#34;) } fun printId() = println(\u0026#34;1234\u0026#34;) } interface Order { fun add(product: Product) { println(\u0026#34;${product.name} 주문이 완료되었습니다\u0026#34;) } fun printId() = println(\u0026#34;5678\u0026#34;) } class MyCart(override var coin: Int) : Cart, Order { override fun add(product: Product) { if (coin \u0026lt;= 0) println(\u0026#34;코인을 넣어주세요\u0026#34;) else println(\u0026#34;${product.name}이(가) 카트에 추가됐습니다\u0026#34;) // 주문하기 super\u0026lt;Order\u0026gt;.add(product) } override fun printId() { super\u0026lt;Cart\u0026gt;.printId() super\u0026lt;Order\u0026gt;.printId() } } fun main() { val cart = MyCart(coin = 100) cart.rent() cart.roll() cart.add(Product(name = \u0026#34;장난감\u0026#34;, price = 1000)) cart.printId() } Collection # import java.util.* import java.util.stream.Collectors import kotlin.collections.ArrayList fun main() { // immutable val currencyList = listOf(\u0026#34;달러\u0026#34;, \u0026#34;유로\u0026#34;, \u0026#34;원\u0026#34;) // mutable val mutableCurrencyList: MutableList\u0026lt;String\u0026gt; = mutableListOf\u0026lt;String\u0026gt;().apply { add(\u0026#34;달러\u0026#34;) add(\u0026#34;유로\u0026#34;) add(\u0026#34;원\u0026#34;) } mutableCurrencyList.add(\u0026#34;파운드\u0026#34;) // immutable set val numberSet = setOf(1, 2, 3, 4) // mutable set val mutableSet = mutableSetOf\u0026lt;Int\u0026gt;().apply { add(1) add(2) add(3) add(4) } // immutable map val numberMap = mapOf(\u0026#34;one\u0026#34; to 1, \u0026#34;two\u0026#34; to 2) // mutable map val mutableNumberMap = mutableMapOf\u0026lt;String, Int\u0026gt;() mutableNumberMap[\u0026#34;one\u0026#34;] = 1 mutableNumberMap[\u0026#34;two\u0026#34;] = 2 mutableNumberMap[\u0026#34;three\u0026#34;] = 3 // 컬렉션 빌더는 내부에선 mutable 반환은 immutable val numberList: List\u0026lt;Int\u0026gt; = buildList{ add(1) add(2) add(3) add(4) } // linkedList val linkedList = LinkedList\u0026lt;Int\u0026gt;().apply { addFirst(3) add(2) addLast(1) } // arrayList val arrayList = ArrayList\u0026lt;Int\u0026gt;().apply { add(1) add(2) add(3) } // val iterator = currencyList.iterator() // while (iterator.hasNext()) { // println(iterator.next()) // } // // println(\u0026#34;===============\u0026#34;) // // for (currency in currencyList) { // println(currency) // } // // println(\u0026#34;===============\u0026#34;) // // currencyList.forEach { // println(it) // } // for loop -\u0026gt; map val lowerList = listOf(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;) //val upperList = mutableListOf\u0026lt;String\u0026gt;() // for (lowerCase in lowerList) { // upperList.add(lowerCase.uppercase()) // } val upperList = lowerList.map { it.uppercase() } //val filteredList = mutableListOf\u0026lt;String\u0026gt;() // for (upperCase in upperList) { // if (upperCase == \u0026#34;A\u0026#34; || upperCase == \u0026#34;C\u0026#34; ) { // filteredList.add(upperCase) // } // } val filteredList = upperList .asSequence() // 대량데이터의 경우 이걸 사용하는게 좋다. .filter { it == \u0026#34;A\u0026#34; || it == \u0026#34;C\u0026#34; } .toList() println(filteredList) } Data Calss # data class Person(val name: String, val age: Int) { } fun main() { val person1 = Person(name = \u0026#34;tony\u0026#34;, age = 12) val (name, age) = person1 println(\u0026#34;이름=${name}, 나이=${age}\u0026#34;) // val set = hashSetOf(person1) // println(set.contains(person1)) } Singleton # import java.time.LocalDateTime //object Singleton { // // val a = 1234 // // fun printA() = println(a) //} // //fun main() { // println(Singleton.a) // Singleton.printA() //} //object DatetimeUtils { // // val now : LocalDateTime // get() = LocalDateTime.now() // // const val DEFAULT_FORMAT = \u0026#34;YYYY-MM-DD\u0026#34; // // fun same(a: LocalDateTime, b: LocalDateTime) : Boolean { // return a == b // } // //} // //fun main() { // println(DatetimeUtils.now) // println(DatetimeUtils.now) // println(DatetimeUtils.now) // // println(DatetimeUtils.DEFAULT_FORMAT) // // val now = LocalDateTime.now() // println(DatetimeUtils.same(now, now)) //} class MyClass { private constructor() companion object MyCompanion { val a = 1234 fun newInstance() = MyClass() } } fun main() { println(MyClass.a) println(MyClass.newInstance()) println(MyClass.a) println(MyClass.newInstance()) } Sealed Class # sealed class Developer { abstract val name: String abstract fun code(language: String) } data class BackendDeveloper(override val name: String) : Developer() { override fun code(language: String) { println(\u0026#34;저는 백엔드 개발자입니다 ${language}를 사용합니다\u0026#34;) } } data class FrontendDeveloper(override val name: String) : Developer() { override fun code(language: String) { println(\u0026#34;저는 프론트엔드 개발자입니다 ${language}를 사용합니다\u0026#34;) } } object OtherDeveloper : Developer() { override val name: String = \u0026#34;익명\u0026#34; override fun code(language: String) { TODO(\u0026#34;Not yet implemented\u0026#34;) } } data class AndroidDeveloper(override val name: String) : Developer() { override fun code(language: String) { println(\u0026#34;저는 안드로이드 개발자입니다 ${language}를 사용합니다\u0026#34;) } } data class IosDeveloper(override val name: String) : Developer() { override fun code(language: String) { println(\u0026#34;저는 Ios 개발자입니다 ${language}를 사용합니다\u0026#34;) } } object DeveloperPool { val pool = mutableMapOf\u0026lt;String, Developer\u0026gt;() // 컴파일러는 Developer 구현 클래스가 무엇인지를 모름 // else가 없으면 when절에 컴파일 오류남 // Developer 를 sealed Class로 정의하면 else문 생략가능 // 같은 패키지/하위 모듈에 있는 경우에만 sealed class의 하위클래스가 될 수 있다 // 컴파일러가 Developer 의 자식클래스를 알고있끼 때문이다. fun add(developer: Developer) = when(developer) { is BackendDeveloper -\u0026gt; pool[developer.name] = developer is FrontendDeveloper -\u0026gt; pool[developer.name] = developer is AndroidDeveloper -\u0026gt; pool[developer.name] = developer is IosDeveloper -\u0026gt; pool[developer.name] = developer is OtherDeveloper -\u0026gt; println(\u0026#34;지원하지않는 개발자종류입니다\u0026#34;) } fun get(name: String) = pool[name] } fun main() { val backendDeveloper = BackendDeveloper(name=\u0026#34;토니\u0026#34;) DeveloperPool.add(backendDeveloper) val frontendDeveloper = FrontendDeveloper(name=\u0026#34;카즈야\u0026#34;) DeveloperPool.add(frontendDeveloper) val androidDeveloper = AndroidDeveloper(name=\u0026#34;안드로\u0026#34;) DeveloperPool.add(androidDeveloper) println(DeveloperPool.get(\u0026#34;토니\u0026#34;)) println(DeveloperPool.get(\u0026#34;카즈야\u0026#34;)) println(DeveloperPool.get(\u0026#34;안드로\u0026#34;)) } Extension # /** * 문자열 첫번째 원소 리턴 */ fun String.first() : Char { return this[0] } fun String.addFirst(char: Char) : String { // this : 수신자 객체 return char + this.substring(0) } class MyExample { fun printMessage() = println(\u0026#34;클래스 출력\u0026#34;) } // MyExample의 확장함수 생성 // printMessage 멤버함수와 이름을 동일하게 했을때 멤버함수가 우선적으로 수행된다. // 확장함수의 멤버함수와 동일한 시그니처는 멤버함수가 실행됨 fun MyExample.printMessage() = println(\u0026#34;확장 출력\u0026#34;) // 시그니처가 다르면 확장함수 실행이 잘 됨 fun MyExample.printMessage(message:String) = println(message) // MyExample 이 null일 가능성이 존재 // null인 경우와 아닌 경우 분기처리 fun MyExample?.printNullOrNotNull() { if (this == null) println(\u0026#34;널인 경우에만 출력\u0026#34;) else println(\u0026#34;널이 아닌 경우에만 출력\u0026#34;) } fun main() { var myExample: MyExample? = null // 함수에서 null 체크를 하고있다는걸 컴파일러가 알고있어서 오류가 안난다. myExample.printNullOrNotNull() myExample = MyExample() myExample.printNullOrNotNull() //MyExample().printMessage(\u0026#34;확장 출력\u0026#34;) // println(\u0026#34;ABCD\u0026#34;.first()) // // println(\u0026#34;ABCD\u0026#34;.addFirst(\u0026#39;Z\u0026#39;)) } Generics # class MyGenerics\u0026lt;out T\u0026gt;(val t: T) { // 공변성은 자바 제네릭의 extends 코틀린에선 out } class Bag\u0026lt;T\u0026gt; { fun saveAll( to: MutableList\u0026lt;in T\u0026gt;, // 반공변성은 자바 제네릭의 super 코틀린에선 in from: MutableList\u0026lt;T\u0026gt;, ) { to.addAll(from) } } fun main() { val bag = Bag\u0026lt;String\u0026gt;() // String이 CharSequence의 하위타입인데, // 반공변성에서는 mutableListOf\u0026lt;CharSequence\u0026gt;가 mutableListOf\u0026lt;String\u0026gt;의 하위타입이 된다. bag.saveAll(mutableListOf\u0026lt;CharSequence\u0026gt;(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;), mutableListOf\u0026lt;String\u0026gt;(\u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;)) // MyGenerics\u0026lt;CharSequence\u0026gt; 가 MyGenerics\u0026lt;String\u0026gt; 보다 상위타입 val generics = MyGenerics\u0026lt;String\u0026gt;(\u0026#34;테스트\u0026#34;) val charGenerics : MyGenerics\u0026lt;CharSequence\u0026gt; = generics // 제네릭을 사용한 클래스의 인스턴스를 만드려면 타입아규먼트를 제공 (컴파일러 타입 추론 가능) val generics2 = MyGenerics\u0026lt;String\u0026gt;(\u0026#34;테스트\u0026#34;) // 생략가능 val generics3 = MyGenerics(\u0026#34;테스트\u0026#34;) // 변수의 타입에 제네릭을 사용한 경우 val list1: MutableList\u0026lt;String\u0026gt; = mutableListOf() // 타입아규먼트를 생성자에서 추가 val list2 = mutableListOf\u0026lt;String\u0026gt;() val list3 : List\u0026lt;*\u0026gt; = listOf\u0026lt;String\u0026gt;(\u0026#34;테스트\u0026#34;) val list4: List\u0026lt;*\u0026gt; = listOf\u0026lt;Int\u0026gt;(1, 2, 3, 4) // PECS는 Producer-Extends, Consumer-Super // 공변성은 자바 제네릭의 extends 코틀린에선 out // -\u0026gt; 공변성 : T’가 T의 서브타입이면, C\u0026lt;T’\u0026gt;는 C\u0026lt;out T\u0026gt;의 서브타입이다. // 반공변성은 자바 제네릭의 super 코틀린에선 in // -\u0026gt; 반공변성 : T’가 T의 서브타입이면, C\u0026lt;T\u0026gt;는 C\u0026lt;in T’\u0026gt;의 서브타입이다. } Late init # class `7_LateInit` { // 가변 프로퍼티에 대한 지연 초기화 // nullable이 아님에도 초기호 안했어도 컴파일 오류가 발생하지 않는다. lateinit var text: String // var : 가변 val textInitialized: Boolean // isInitialized 는 클래스 내부에서만 사용 가능하다. (Main 등에서 사용 불가능) get() = this::text.isInitialized // 초기화 여부 fun printText() { println(text) } } fun a (str:String, block: (String) -\u0026gt; Unit) { block(str) } fun main() { \u0026#34;\u0026#34;.let { } a(\u0026#34;\u0026#34;) { it.length } val test = `7_LateInit`() if (!test.textInitialized) { test.text = \u0026#34;하이요\u0026#34; } test.printText() // 초기화 전에 출력 요청하면 오류 발생 } Lazy init # class HelloBot { // val 불변 // by lazy 사용 (멀티쓰레드 안전) // 기본 : LazyThreadSafetyMode.SYNCHRONIZED // LazyThreadSafetyMode.NONE 등 상태값을 설정하여 쓰레드 안전성 무시 가능 // 불변을 유지하면서 변수에 대한 초기화를 뒤로 미룰수 있다. // 변수가 처음으로 사용될 때까지 해당 변수의 초기화를 늦춘다. // -\u0026gt; 즉, 변수에 처음으로 접근하는 시점에서 초기화 코드가 실행 val greeting: String by lazy(LazyThreadSafetyMode.PUBLICATION) { // 멀티쓰레드 환경에서도 동기화가 필요하지 않을때 : LazyThreadSafetyMode.PUBLICATION // 한 번 초기화된 이후에는 모든 스레드가 같은 값을 공유 // 따라서 여러 스레드에서 동시에 초기화를 시도하더라도 최초 한 번만 초기화가 이루어지고 나면 이후에는 초기화 코드가 다시 실행되지않음 getHello() } fun sayHello() = println(greeting) } fun getHello() = \u0026#34;안녕하세요\u0026#34; fun main() { val helloBot = HelloBot() // 초기화 이후에는 더이상 by lazy {}을 수행하지 않음 // ... // ... for (i in 1..5) { Thread { // 쓰레드 생성하여 병렬로 수행해보자 helloBot.sayHello() // 변수 초기화 첫 실행 }.start() } } Pair Destructuring # // f((1, 3)) = 1 + 3 = 4 // f(1, 3) = 1 + 3 = 4 //data class Tuple(val a : Int, val b: Int) fun plus(pair: Pair\u0026lt;Int, Int\u0026gt;) = pair.first + pair.second fun main() { //println(plus(1,3)) val plus = plus(Pair(1, 3)) println(plus) val pair = Pair(\u0026#34;A\u0026#34;, 1) // 불변 val newPair = pair.copy(first = \u0026#34;B\u0026#34;) // 새로운 Pair을 생성 println(newPair) val second = newPair.component2() // second 값 가져오기 println(second) val list = newPair.toList() println(list) /* 3개 요소 (4개 이상부터는 지원하지 않음, Collection 사용하면 됨) */ val triple = Triple(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;) println(triple) // 출력 triple.first triple.second val newTriple = triple.copy(third = \u0026#34;D\u0026#34;) // third 값 변경한 새로운 Triple 생성 println(newTriple) println(newTriple.component3()) /* 구조분해 할당 */ val (a: String, b: String, c: String) = newTriple println(\u0026#34;$a, $b, $c\u0026#34;) val list3: List\u0026lt;String\u0026gt; = newTriple.toList() val (a1, a2, a3) = list3 println(\u0026#34;$a1, $a2, $a3\u0026#34;) list3.component1() list3.component2() list3.component3() // list3.component4() // list3.component5() val map = mutableMapOf(Pair(\u0026#34;이상훈\u0026#34;, \u0026#34;개발자\u0026#34;)) for ( (key, value) in map ) { println(\u0026#34;${key}의 직업은 $value\u0026#34;) } } 범위 지정 함수 # (이미지 출처 : https://medium.com/@limgyumin/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%98-apply-with-let-also-run-%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-4a517292df29)\nRun # run 정의 inline fun \u0026lt;T, R\u0026gt; T.run(block: T.() -\u0026gt; R): R { return block() } 예제코드 class DatabaseClient { var url: String? = null var username: String? = null var password: String? = null // DB에 접속하고 Boolean 결과를 반환 fun connect(): Boolean { println(\u0026#34;DB 접속 중 ...\u0026#34;) Thread.sleep(1000) println(\u0026#34;DB 접속 완료\u0026#34;) return true } } fun main() { // val config = DatabaseClient() // config.url = \u0026#34;localhost:3306\u0026#34; // config.username = \u0026#34;mysql\u0026#34; // config.password = \u0026#34;1234\u0026#34; // val connected = config.connect() // run 안에서 수신자 객체 참조는 this로 함 (생략도 가능) // 변수 중복 참조를 생략할 수 있다는 장점 (위에서 config.xx가 반복됨) val connected: Boolean = DatabaseClient().run { url = \u0026#34;localhost:3306\u0026#34; username = \u0026#34;mysql\u0026#34; this.password = \u0026#34;1234\u0026#34; connect() // 자동 return } println(connected) val result: Boolean = with(DatabaseClient()) { url = \u0026#34;localhost:3306\u0026#34; username = \u0026#34;mysql\u0026#34; password = \u0026#34;1234\u0026#34; connect() } println(result) } Also # also 정의 inline fun \u0026lt;T\u0026gt; T.also(block: (T) -\u0026gt; Unit): T { block(this) return this } 예제 class User(val name: String, val password: String) { fun validate() { if (name.isNotEmpty() \u0026amp;\u0026amp; password.isNotEmpty()) { println(\u0026#34;검증 성공!\u0026#34;) } else { println(\u0026#34;검증 실패!\u0026#34;) } } fun printName() = println(name) } fun main() { User(name = \u0026#34;tony\u0026#34;, password = \u0026#34;1234\u0026#34;).also { // it을 사용해서 간결하게 사용 가능 it.validate() it.printName() } } Apply # apply 정의 inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { block() return this } 예제코드 fun main() { // return 타입이 Context 객체에 대한 타입 그대로 (DatabaseClient) DatabaseClient().apply { url = \u0026#34;localhost:3306\u0026#34; username = \u0026#34;mysql\u0026#34; this.password = \u0026#34;1234\u0026#34; }.connect() .run { println(this) } // this : connect() 함수의 반환결과 } Let # let 정의 inline fun \u0026lt;T, R\u0026gt; T.let(block: (T) -\u0026gt; R): R { return block(this) } 예제코드 fun main() { val str: String? = \u0026#34;안녕\u0026#34; // str 이 null이 아닌 경우에 동작한다. val result: Int? = str?.let { println(it) // it = str val abc: String? = \u0026#34;abc\u0026#34; val def: String? = \u0026#34;def\u0026#34; if (!abc.isNullOrEmpty() \u0026amp;\u0026amp; !def.isNullOrEmpty()) { println(\u0026#34;abcdef가 null 아님\u0026#34;) } // return 키워드 없이도 return 값으로 셋팅된다. 1234 } println(result) // val this: String? = null // val it : String? = null val hello = \u0026#34;hello\u0026#34; val hi = \u0026#34;hi\u0026#34; hello.let { a : String -\u0026gt; //println(a.length) hi.let{ b -\u0026gt; println(a.length) println(b.length) } } } With # with 정의 inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { return receiver.block() } 예제 fun main() { val str = \u0026#34;안녕하세요\u0026#34; // val length: Int = with(str) { length // return 생략 가능 } println(length) } "},{"id":28,"href":"/docs/reactive-streams/002_impl1_reactor/","title":"002 Impl1 Reactor","section":"Reactive Streams","content":" Reactive Streams 구현 라이브러리 (1) Reactor # Project reactor # Pivotal 사에서 개발 Spring reactor에서 사용 Mono와 Flux publisher 제공 Project reactor - Flux # 0..n개의 item을 전달 에러가 발생하면 error signal 전달하고 종료 모든 item을 전달했다면 complete signal 전달 하고 종료 backPressure 지원 Flux 예제 # SimpleSubscriber\nFluxIterable publisher Subscription : StrictSubscriber @Slf4j @RequiredArgsConstructor public class p181_SimpleSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; { private final Integer count; /** * 지속적으로 요청을 하는게 아니라, 딱 한번 N개의 요청을 받고 그 이후로 값을 계속 받음 * @param s the {@link Subscription} that allows requesting data via {@link Subscription#request(long)} */ @Override public void onSubscribe(Subscription s) { log.info(\u0026#34;subscribe\u0026#34;); s.request(count); // count만큼 request log.info(\u0026#34;request: {}\u0026#34;, count); } @SneakyThrows @Override public void onNext(T t) { log.info(\u0026#34;item: {}\u0026#34;, t); Thread.sleep(100); } @Override public void onError(Throwable t) { log.error(\u0026#34;error: {}\u0026#34;, t.getMessage()); } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } } FluxSimpleExample\n@Slf4j public class p181_FluxSimpleExample { @SneakyThrows public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); // main 쓰레드에서 수행 getItems() // 고정된 개수를 subscribe .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); Thread.sleep(1000); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } 실행결과\n13:18:58.672 [main] INFO com.example06.reactor.p181_FluxSimpleExample - start main 13:18:58.733 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 13:18:58.736 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 13:18:58.736 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 13:18:58.737 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 13:18:58.904 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 2 13:18:59.049 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 3 13:18:59.233 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 4 13:18:59.399 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 5 13:18:59.578 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 13:18:59.578 [main] INFO com.example06.reactor.p181_FluxSimpleExample - end main Flux - subscribeOn 예제 # FluxSimpleSubscribeOnExample\n@Slf4j public class p182_FluxSimpleSubscribeOnExample { @SneakyThrows public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() .map(i -\u0026gt; { log.info(\u0026#34;map {}\u0026#34;, i); return i; }) // main 쓰레드가 아닌 다른 쓰레드에서 수행 .subscribeOn(Schedulers.single()) .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); // 바로 호출 Thread.sleep(1000); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } 실행결과\nsingle-1 쓰레드에서 수행 13:22:13.042 [main] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - start main 13:22:13.094 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 13:22:13.120 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 13:22:13.120 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 13:22:13.122 [main] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - end main 13:22:13.124 [single-1] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - map 1 13:22:13.124 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 13:22:13.264 [single-1] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - map 2 13:22:13.264 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - item: 2 13:22:13.440 [single-1] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - map 3 13:22:13.441 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - item: 3 13:22:13.613 [single-1] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - map 4 13:22:13.614 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - item: 4 13:22:13.789 [single-1] INFO com.example06.reactor.p182_FluxSimpleSubscribeOnExample - map 5 13:22:13.789 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - item: 5 13:22:13.969 [single-1] INFO com.example06.reactor.p181_SimpleSubscriber - complete Flux - subscribe # FluxNoSubscribeExample\nsubscribe하지 않으면, 아무 일도 일어나지 않는다. @Slf4j public class p183_FluxNoSubscribeExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems(); // subscribe 하지않으면 아무일도 일어나지 않는다. log.info(\u0026#34;end main\u0026#34;); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.create(fluxSink -\u0026gt; { log.info(\u0026#34;start getItems\u0026#34;); for (int i = 0; i \u0026lt; 5; i++) { fluxSink.next(i); } fluxSink.complete(); log.info(\u0026#34;end getItems\u0026#34;); }); } } Flux - backPressure # 1번째 예제 @Slf4j public class p184_FluxSimpleRequestThreeExample { public static void main(String[] args) { // 3개 요청 (1, 2, 3 이후 종료) , 추가적인 요청 없음 getItems().subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(3)); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } SimpleSubscriber\n@Slf4j @RequiredArgsConstructor public class p181_SimpleSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; { private final Integer count; /** * 지속적으로 요청을 하는게 아니라, 딱 한번 N개의 요청을 받고 그 이후로 값을 계속 받음 * @param s the {@link Subscription} that allows requesting data via {@link Subscription#request(long)} */ @Override public void onSubscribe(Subscription s) { log.info(\u0026#34;subscribe\u0026#34;); s.request(count); // count만큼 request log.info(\u0026#34;request: {}\u0026#34;, count); } ... } 실행결과\n09:24:32.953 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:24:32.957 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:24:32.957 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 3 09:24:32.958 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:24:33.091 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 2 09:24:33.232 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 3 2번째 예제 @Slf4j public class p185_FluxContinuousRequestSubscriberExample { public static void main(String[] args) { getItems().subscribe(new p185_ContinuousRequestSubscriber\u0026lt;\u0026gt;()); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } ContinuousRequestSubscriber\n@Slf4j public class p185_ContinuousRequestSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; { private final Integer count = 1; private Subscription subscription; @Override public void onSubscribe(Subscription s) { this.subscription = s; log.info(\u0026#34;subscribe\u0026#34;); s.request(count); // 개수만큼 요청 log.info(\u0026#34;request: {}\u0026#34;, count); } @SneakyThrows @Override public void onNext(T t) { log.info(\u0026#34;item: {}\u0026#34;, t); Thread.sleep(1000); // 1개를 또 호출 subscription.request(1); log.info(\u0026#34;request: {}\u0026#34;, count); } @Override public void onError(Throwable t) { log.error(\u0026#34;error: {}\u0026#34;, t.getMessage()); } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } } 아래 로직으로 계속 반복 수행한다. // 1개를 또 호출 subscription.request(1); 실행결과\n09:33:34.419 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:33:34.424 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - subscribe 09:33:34.424 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:34.425 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 1 09:33:35.445 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:35.445 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 2 09:33:36.518 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:36.518 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 3 09:33:37.589 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:37.589 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 4 09:33:38.655 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:38.655 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 5 09:33:39.718 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:33:39.727 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - complete Flux - error # @Slf4j public class p186_FluxErrorExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems().subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.create(fluxSink -\u0026gt; { fluxSink.next(0); fluxSink.next(1); var error = new RuntimeException(\u0026#34;error in flux\u0026#34;); fluxSink.error(error); // 에러 전달 }); } } 실행결과\n09:36:46.692 [main] INFO com.example06.reactor.p186_FluxErrorExample - start main 09:36:46.756 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:36:46.762 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:36:46.762 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:36:46.764 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 0 09:36:46.885 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:36:47.028 [main] ERROR com.example06.reactor.p181_SimpleSubscriber - error: error in flux 09:36:47.028 [main] INFO com.example06.reactor.p186_FluxErrorExample - end main Flux - complete # @Slf4j public class p187_FluxCompleteExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems().subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.create(fluxSink -\u0026gt; { fluxSink.complete(); // complete 전달 }); } } 실행결과\n09:37:31.038 [main] INFO com.example06.reactor.p187_FluxCompleteExample - start main 09:37:31.100 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:37:31.106 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:37:31.106 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:37:31.109 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:37:31.109 [main] INFO com.example06.reactor.p187_FluxCompleteExample - end main Project reactor - Mono # 0..1개의 item을 전달 에러가 발생하면 error signal 전달하고 종료 모든 item을 전달했다면 complete signal 전달 하고 종료 Mono 예제 # 1개의 item만 전달하기 때문에 next 하나만 실행하면 complete가 보장 혹은 전달하지 않고 complete를 하면 값이 없다는 것을 의미 - 하나의 값이 있거나 없다 @Slf4j public class p190_MonoSimpleExample { @SneakyThrows public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); Thread.sleep(1000); } private static Mono\u0026lt;Integer\u0026gt; getItems() { return Mono.create(monoSink -\u0026gt; { monoSink.success(1); }); } } 실행결과\n09:39:02.445 [main] INFO com.example06.reactor.p190_MonoSimpleExample - start main 09:39:02.481 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:39:02.484 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:39:02.484 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:39:02.484 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:39:02.658 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:39:02.658 [main] INFO com.example06.reactor.p190_MonoSimpleExample - end main Mono와 Flux # Mono : Optional\n없거나 혹은 하나의 값 Mono로 특정 사건이 완료되는 시점을 가리킬 수도 있다 Flux: List\n무한하거나 유한한 여러 개의 값 Flux를 Mono로 변환 # Mono.from으로 Flux를 Mono로 변환 첫 번째 값만 전달 @Slf4j public class p192_FluxToMonoExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); // 1,2,3,4,5 중 첫번째값 1이 onNext로 전달되고 complete // 뒤에 있는 값들은 모두 무시 Mono.from(getItems()) .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } 실행결과\n09:40:37.275 [main] INFO com.example06.reactor.p192_FluxToMonoExample - start main 09:40:37.340 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:40:37.363 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:40:37.363 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:40:37.365 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:40:37.473 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:40:37.473 [main] INFO com.example06.reactor.p192_FluxToMonoExample - end main Flux를 Mono로 변환 (Mono\u0026lt;List\u0026gt;) # @Slf4j public class p193_FluxToListMonoExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() // collect 하고 complete 이벤트 발생 시점에 모은 값들을 모두 전달 // 1, 2, 3, 4, 5를 내부 배열에 저장하고, 가지고있던 값들을 모두 onNext() 한다. // 하나로 합쳐져서 Mono로 한번 요청됨 ([1,2,3,4,5]) .collectList() .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Flux\u0026lt;Integer\u0026gt; getItems() { return Flux.fromIterable(List.of(1, 2, 3, 4, 5)); } } 실행결과\n09:41:24.680 [main] INFO com.example06.reactor.p193_FluxToListMonoExample - start main 09:41:24.743 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:41:24.766 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:41:24.766 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:41:24.767 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: [1, 2, 3, 4, 5] 09:41:24.940 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:41:24.940 [main] INFO com.example06.reactor.p193_FluxToListMonoExample - end main Mono를 Flux로 변환 # flux() Mono를 next 한 번 호출하고 onComplete를 호출하는 Flux로 변환 @Slf4j public class p194_MonoToFluxExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); // flux() - Mono를 next 한번 호출하고 onComplete를 호출하는 Flux로 변환 // [1,2,3,4,5] getItems().flux() .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Mono\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; getItems() { return Mono.just(List.of(1, 2, 3, 4, 5)); } } 실행결과\n09:42:16.606 [main] INFO com.example06.reactor.p194_MonoToFluxExample - start main 09:42:16.650 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:42:16.694 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:42:16.695 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:42:16.695 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: [1, 2, 3, 4, 5] 09:42:16.802 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:42:16.802 [main] INFO com.example06.reactor.p194_MonoToFluxExample - end main Mono를 Flux로 변환 (Mono\u0026lt;List\u0026gt; -\u0026gt; Flux) # @Slf4j public class p195_ListMonoToFluxExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() // Mono의 결과를 Flux 형태로 바꾸고, flux를 받아서 처리 // 1, 2, 3, 4, 5 하나씩 처리 .flatMapMany(value -\u0026gt; Flux.fromIterable(value)) .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Mono\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; getItems() { return Mono.just(List.of(1, 2, 3, 4, 5)); } } 실행결과\n09:43:07.895 [main] INFO com.example06.reactor.p195_ListMonoToFluxExample - start main 09:43:07.931 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework 09:43:07.972 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:43:07.972 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:43:07.972 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:43:08.082 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 2 09:43:08.239 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 3 09:43:08.414 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 4 09:43:08.588 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 5 09:43:08.724 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:43:08.724 [main] INFO com.example06.reactor.p195_ListMonoToFluxExample - end main References 1) 강의 : Spring Webflux 완전 정복 : 코루틴부터 리액티브 MSA 프로젝트까지\n2) github 예제코드 : https://github.com/seohaebada/webflux "},{"id":29,"href":"/docs/reactive-streams/003_impl2_rxjava/","title":"003 Impl2 Rxjava","section":"Reactive Streams","content":" Reactive Streams 구현 라이브러리 (2) RxJava # RxJava # Netflix 사에서 개발 닷넷 프레임워크를 지원하는 Reactive Extensions를 포팅 Flowable, Observable, Single, Maybe, Completable, publisher 제공 RxJava - Flowable # 0..n개의 item을 전달 에러가 발생하면 error signal 전달 하고 종료 모든 item을 전달했다면 complete signal 전달하고 종료 backPressure 지원 Reactor의 Flux와 유사 Flowable 예제 # @Slf4j public class p199_FlowableExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() .subscribe(new p181_SimpleSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); log.info(\u0026#34;end main\u0026#34;); } private static Flowable\u0026lt;Integer\u0026gt; getItems() { return Flowable.fromIterable(List.of(1, 2, 3, 4, 5)); } } 실행결과\n09:53:02.296 [main] INFO com.example06.rxjava.p199_FlowableExample - start main 09:53:02.339 [main] INFO com.example06.reactor.p181_SimpleSubscriber - subscribe 09:53:02.339 [main] INFO com.example06.reactor.p181_SimpleSubscriber - request: 2147483647 09:53:02.340 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 1 09:53:02.450 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 2 09:53:02.622 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 3 09:53:02.762 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 4 09:53:02.933 [main] INFO com.example06.reactor.p181_SimpleSubscriber - item: 5 09:53:03.112 [main] INFO com.example06.reactor.p181_SimpleSubscriber - complete 09:53:03.114 [main] INFO com.example06.rxjava.p199_FlowableExample - end main Flowable - backPressure 예제 # @Slf4j public class p200_FlowableContinuousRequestSubscriberExample { public static void main(String[] args) { log.info(\u0026#34;start main\u0026#34;); getItems() // 1개씩 처리 (backPressure) .subscribe(new p185_ContinuousRequestSubscriber\u0026lt;\u0026gt;()); log.info(\u0026#34;end main\u0026#34;); } private static Flowable\u0026lt;Integer\u0026gt; getItems() { return Flowable.fromIterable(List.of(1, 2, 3, 4, 5)); } } ContinuousRequestSubscriber\n@Slf4j public class p185_ContinuousRequestSubscriber\u0026lt;T\u0026gt; implements Subscriber\u0026lt;T\u0026gt; { private final Integer count = 1; private Subscription subscription; @Override public void onSubscribe(Subscription s) { this.subscription = s; log.info(\u0026#34;subscribe\u0026#34;); s.request(count); // 개수만큼 요청 log.info(\u0026#34;request: {}\u0026#34;, count); } @SneakyThrows @Override public void onNext(T t) { log.info(\u0026#34;item: {}\u0026#34;, t); Thread.sleep(1000); // 1개를 또 호출 subscription.request(1); log.info(\u0026#34;request: {}\u0026#34;, count); } @Override public void onError(Throwable t) { log.error(\u0026#34;error: {}\u0026#34;, t.getMessage()); } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } } 실행결과\n09:54:17.223 [main] INFO com.example06.rxjava.p200_FlowableContinuousRequestSubscriberExample - start main 09:54:17.258 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - subscribe 09:54:17.259 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:17.260 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 1 09:54:18.335 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:18.335 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 2 09:54:19.408 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:19.409 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 3 09:54:20.483 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:20.484 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 4 09:54:21.544 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:21.545 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - item: 5 09:54:22.618 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - request: 1 09:54:22.623 [main] INFO com.example06.reactor.p185_ContinuousRequestSubscriber - complete 09:54:22.623 [main] INFO com.example06.rxjava.p200_FlowableContinuousRequestSubscriberExample - end main RxJava - Observable # 0..n개의 item을 전달 에러가 발생하면 error signal 전달 하고 종료 모든 item을 전달했다면 complete signal 전달하고 종료 backPressure 지원 X Observable vs Flowable # Observable Flowable Push 기반 Pull 기반 Subscriber가 처리할 수 없더라도 item을 전달 Subscriber가 request의 수를 조절 Reactive manifesto의 message driven을 일부만 준수 Reactive manifesto의 message driven을 모두 준수 onSubscribe로 Disposable 전달 onSubscribe시 Subscription 전 달\nObservable 예제 # @Slf4j public class p203_ObservableExample { public static void main(String[] args) { // 배압 조절 불가능 getItems() .subscribe(new p203_SimpleObserver()); } private static Observable\u0026lt;Integer\u0026gt; getItems() { return Observable.fromIterable(List.of(1, 2, 3, 4, 5)); } } SimpleObserver\n@Slf4j public class p203_SimpleObserver implements Observer { private Disposable disposable; @Override public void onSubscribe(@NonNull Disposable d) { log.info(\u0026#34;subscribe\u0026#34;); this.disposable = d; } @Override public void onNext(@NonNull Object o) { log.info(\u0026#34;item: {}\u0026#34;, o); } @Override public void onError(@NonNull Throwable e) { log.error(\u0026#34;error: {}\u0026#34;, e.getMessage()); } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } } 실행결과\n09:57:21.403 [main] INFO com.example06.rxjava.p203_SimpleObserver - subscribe 09:57:21.404 [main] INFO com.example06.rxjava.p203_SimpleObserver - item: 1 09:57:21.404 [main] INFO com.example06.rxjava.p203_SimpleObserver - item: 2 09:57:21.404 [main] INFO com.example06.rxjava.p203_SimpleObserver - item: 3 09:57:21.404 [main] INFO com.example06.rxjava.p203_SimpleObserver - item: 4 09:57:21.405 [main] INFO com.example06.rxjava.p203_SimpleObserver - item: 5 09:57:21.405 [main] INFO com.example06.rxjava.p203_SimpleObserver - complete RxJava - Single # 1개의 item을 전달 후 바로 onComplete signal 전달 1개의 item이 없다면 onError signal 전달 에러가 발생했다면 onError signal 전달 Single - success 예제 # public class p205_SingleExample { public static void main(String[] args) { getItem() .subscribe(new p205_SimpleSingleObserver\u0026lt;\u0026gt;()); } private static Single\u0026lt;Integer\u0026gt; getItem() { return Single.create(singleEmitter -\u0026gt; { singleEmitter.onSuccess(1); }); } } SimpleSingleObserver\n@Slf4j public class p205_SimpleSingleObserver\u0026lt;T\u0026gt; implements SingleObserver\u0026lt;T\u0026gt; { private Disposable disposable; @Override public void onSubscribe(@NonNull Disposable d) { this.disposable = d; log.info(\u0026#34;subscribe\u0026#34;); } @Override public void onSuccess(@NonNull Object o) { log.info(\u0026#34;item: {}\u0026#34;, o); } @Override public void onError(@NonNull Throwable e) { log.error(\u0026#34;error: {}\u0026#34;, e.getMessage()); } } 실행결과\n09:58:59.778 [main] INFO com.example06.rxjava.p205_SimpleSingleObserver - subscribe 09:58:59.780 [main] INFO com.example06.rxjava.p205_SimpleSingleObserver - item: 1 Single - error (빈 값) # @Slf4j public class p206_SingleNullExample { public static void main(String[] args) { getItem() .subscribe(new p205_SimpleSingleObserver\u0026lt;\u0026gt;()); } private static Single\u0026lt;Integer\u0026gt; getItem() { return Single.create(singleEmitter -\u0026gt; { singleEmitter.onSuccess(null); // 에러 발생시킴 }); } } 실행결과\n09:59:53.191 [main] INFO com.example06.rxjava.p205_SimpleSingleObserver - subscribe 09:59:53.193 [main] ERROR com.example06.rxjava.p205_SimpleSingleObserver - error: onSuccess called with a null value. Null values are generally not allowed in 3.x operators and sources. RxJava - Maybe # 1개의 item을 전달 후 바로 onComplete signal 전달 1개의 item이 없어도 onComplete signal 전달 가능 에러가 발생했다면 onError signal 전달 Reactor의 Mono와 유사 예제 # SimpleMaybeObserver\n@Slf4j public class SimpleMaybeObserver\u0026lt;T\u0026gt; implements MaybeObserver\u0026lt;T\u0026gt; { private Disposable disposable; @Override public void onSubscribe(@NonNull Disposable d) { this.disposable = d; log.info(\u0026#34;subscribe\u0026#34;); } @Override public void onSuccess(@NonNull T t) { log.info(\u0026#34;item: {}\u0026#34;, t); } @Override public void onError(@NonNull Throwable e) { log.error(\u0026#34;error: {}\u0026#34;, e.getMessage()); } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } } Maybe - success 예제 # @Slf4j public class p208_MaybeExample { public static void main(String[] args) { maybeGetItem() .subscribe(new SimpleMaybeObserver\u0026lt;\u0026gt;()); } private static Maybe\u0026lt;Integer\u0026gt; maybeGetItem() { return Maybe.create(maybeEmitter -\u0026gt; { maybeEmitter.onSuccess(1); }); } } 실행결과\n10:42:03.579 [main] INFO com.example06.rxjava.SimpleMaybeObserver - subscribe 10:42:03.581 [main] INFO com.example06.rxjava.SimpleMaybeObserver - item: 1 Maybe - success (빈 값) 예제 # @Slf4j public class p209_MaybeEmptyValueExample { public static void main(String[] args) { maybeGetItem() .subscribe(new SimpleMaybeObserver\u0026lt;\u0026gt;()); } private static Maybe\u0026lt;Integer\u0026gt; maybeGetItem() { return Maybe.create(maybeEmitter -\u0026gt; { maybeEmitter.onComplete(); // complete()만 호출 }); } } 실행결과\n10:42:24.592 [main] INFO com.example06.rxjava.SimpleMaybeObserver - subscribe 10:42:24.593 [main] INFO com.example06.rxjava.SimpleMaybeObserver - complete Maybe - error 예제 # @Slf4j public class p209_MaybeNullValueExample { public static void main(String[] args) { maybeGetItem() .subscribe(new SimpleMaybeObserver\u0026lt;\u0026gt;()); } private static Maybe\u0026lt;Integer\u0026gt; maybeGetItem() { return Maybe.create(maybeEmitter -\u0026gt; { maybeEmitter.onSuccess(null); }); } } 실행결과\n10:42:48.454 [main] INFO com.example06.rxjava.SimpleMaybeObserver - subscribe 10:42:48.456 [main] ERROR com.example06.rxjava.SimpleMaybeObserver - error: onSuccess called with a null value. Null values are generally not allowed in 3.x operators and sources. RxJava - Completable # onComplete 혹은 onError signal만 전달 값이 아닌 사건을 전달 예제 # SimpleCompletableObserver\n@Slf4j public class SimpleCompletableObserver implements CompletableObserver { private Disposable disposable; @Override public void onSubscribe(@NonNull Disposable d) { log.info(\u0026#34;subscribe\u0026#34;); this.disposable = d; } @Override public void onComplete() { log.info(\u0026#34;complete\u0026#34;); } @Override public void onError(@NonNull Throwable e) { log.error(\u0026#34;error: {}\u0026#34;, e.getMessage()); } } Completable - success 예제 # @Slf4j public class p212_CompletableExample { public static void main(String[] args) { getCompletion() .subscribe(new SimpleCompletableObserver()); } private static Completable getCompletion() { return Completable.create(completableEmitter -\u0026gt; { Thread.sleep(1000); completableEmitter.onComplete(); // 값이 아닌 사건을 전달 }); } } 실행결과\n10:43:45.900 [main] INFO com.example06.rxjava.SimpleCompletableObserver - subscribe 10:43:46.924 [main] INFO com.example06.rxjava.SimpleCompletableObserver - complete Completable - error 예제 # @Slf4j public class p213_CompletableErrorExample { public static void main(String[] args) { getCompletion() .subscribe(new SimpleCompletableObserver()); } private static Completable getCompletion() { return Completable.create(completableEmitter -\u0026gt; { Thread.sleep(1000); completableEmitter.onError( new RuntimeException(\u0026#34;error in completable\u0026#34;) ); }); } } 실행결과\n10:44:07.096 [main] INFO com.example06.rxjava.SimpleCompletableObserver - subscribe 10:44:08.124 [main] ERROR com.example06.rxjava.SimpleCompletableObserver - error: error in completable References 1) 강의 : Spring Webflux 완전 정복 : 코루틴부터 리액티브 MSA 프로젝트까지\n2) github 예제코드 : https://github.com/seohaebada/webflux "},{"id":30,"href":"/docs/reactive-streams/004_impl3_munity/","title":"004 Impl3 Munity","section":"Reactive Streams","content":" Reactive Streams 구현 라이브러리 (3) Munity # Mutiny # Hibernate reactive에서 비동기 라이브러리로 제공 Multi, Uni publisher 제공 Mutiny - Multi # 0..n개의 item을 전달 에러가 발생하면 error signal 전달 하고 종료 모든 item을 전달했다면 complete signal 전달하고 종료 backPressure 지원 Reactor의 flux와 유사 Multi 예제 # @Slf4j public class p218_MultiExample { public static void main(String[] args) { getItems() .subscribe() // subscribe 동시에 넘길 수 없음, subscribe() 호출 후 아래 호출 필요 .withSubscriber( new p218_SimpleMultiSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE) ); } private static Multi\u0026lt;Integer\u0026gt; getItems() { return Multi.createFrom().items(1, 2, 3, 4, 5); } } SimpleMultiSubscriber\n@Slf4j @RequiredArgsConstructor public class p218_SimpleMultiSubscriber\u0026lt;T\u0026gt; implements MultiSubscriber\u0026lt;T\u0026gt; { private final Integer count; @Override public void onSubscribe(Flow.Subscription s) { s.request(count); log.info(\u0026#34;subscribe\u0026#34;); } @Override public void onItem(T item) { log.info(\u0026#34;item: {}\u0026#34;, item); } @Override public void onFailure(Throwable failure) { log.error(\u0026#34;fail: {}\u0026#34;, failure.getMessage()); } @Override public void onCompletion() { log.info(\u0026#34;completion\u0026#34;); } } 실행결과\n10:46:36.701 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - item: 1 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - item: 2 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - item: 3 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - item: 4 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - item: 5 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - completion 10:46:36.702 [main] INFO com.example06.mutiny.p218_SimpleMultiSubscriber - subscribe Mutiny - Uni # 0..1개의 item을 전달 에러가 발생하면 error signal 전달 하고 종료 모든 item을 전달했다면 complete signal 전달하고 종료 Reactor의 Mono와 유사 Uni 예제 # @Slf4j public class p220_UniExample { public static void main(String[] args) { getItem() .subscribe() .withSubscriber(new p220_SimpleUniSubscriber\u0026lt;\u0026gt;(Integer.MAX_VALUE)); } private static Uni\u0026lt;Integer\u0026gt; getItem() { return Uni.createFrom().item(1); } } SimpleUniSubscriber\n@Slf4j @RequiredArgsConstructor public class p220_SimpleUniSubscriber\u0026lt;T\u0026gt; implements UniSubscriber\u0026lt;T\u0026gt; { private final Integer count; private UniSubscription subscription; @Override public void onSubscribe(UniSubscription s) { this.subscription = s; s.request(1); log.info(\u0026#34;subscribe\u0026#34;); } @Override public void onItem(T item) { log.info(\u0026#34;item: {}\u0026#34;, item); } @Override public void onFailure(Throwable failure) { log.error(\u0026#34;error: {}\u0026#34;, failure.getMessage()); } } 실행결과\n10:47:27.202 [main] INFO com.example06.mutiny.p220_SimpleUniSubscriber - subscribe 10:47:27.208 [main] INFO com.example06.mutiny.p220_SimpleUniSubscriber - item: 1 References 1) 강의 : Spring Webflux 완전 정복 : 코루틴부터 리액티브 MSA 프로젝트까지\n2) github 예제코드 : https://github.com/seohaebada/webflux "},{"id":31,"href":"/docs/redis/001_redis_datastructure/","title":"001 Redis Datastructure","section":"Redis","content":" 레디스 자료구조 활용사례 # 리더보드 # 경쟁자들의 순위와 현재 점수를 보여주는 순위표를 의미한다. 스코어로 정렬되어 상위 경쟁자의 순위를 보여준다.\n절대적 리더보드 서비스의 모든 유저를 정렬시켜 상위권의 목록만을 표시\n상대적 리더보드 사용자의 스코어를 기반으로 그들을 다른 사용자와 비교해 순위를 결정 ex) 유저와 인접해있는 경쟁자들의 스코어를 보여주는 리더보드, 특정 그룹 내에서의 순위를 보여주는 리더보드, 주간 리더보드\n리더보드는 기본적으로 사용자의 스코어를 기반으로 데이터를 정렬하는 서비스이기 때문에 사용자의 증가에 따라 가공해야할 데이터가 몇 배로 증가한다. 또한 리더보드는 실시간으로 반영돼야하는 데이터다. 데이터가 실시간으로 계산되어, 자신의 순위 변동이 바로 확인되어야한다.\nsorted set을 이용한 리더보드 레디스의 sorted set 은 데이터가 저장될 때부터 정렬된다. 유저의 스코어를 가중치로 설정하여 스코어 순으로 유저를 정렬할 수 있다.\n▶ daily-score:\u0026lt;날짜\u0026gt; 를 이용해 sorted set 키를 만들고, 사용자의 스코어를 가중치로 사용해서 데이터를 입력해보자.\nZADD daily-score:228017 28 player:286 ZADD daily-score:228017 400 player:234 ZADD daily-score:228017 45 player:101 ZADD daily-score:228017 357 player:24 ZADD daily-score:228017 199 player:143 위와 같이 데이터를 저장했다. 데이터는 스코어 순으로 정렬되어 있을 것이다.\nZRANGE daily-score:228017 0 -1 withscores ▶ 상위 유저 3명만 출력 ZREVRANGE는 sorted set에 저장된 데이터를 내림차순으로 반환한다. 0번 인덱스 ~ 2번 인덱스(세번째 데이터)까지 출력한다.\nZREVRANGE daily-score:228017 0 2 withscores ▶ 데이터 업데이트 sorted set은 데이터가 중복으로 저장되지 않으므로, 같은 아이템을 저장하고자 할때 스코어가 다르면 기존 데이터의 스코어만 업데이트한다. 이와 동시에 재정렬된다.\nZADD daily-score:228017 200 player:286 ▶ ZINCRBY 커맨드 스코어를 증감시킬 수 있다.\nZINCRBY daily-score:228017 100 player:24 랭킹 합산 # 주간 리더보드가 매주 월요일마다 초기화된다고 가정하자. 레디스에서 주간 누적 랭킹은 ZUNIONSTORE 커맨드로 간단하게 구현할 수 있다.\n▶ ZUNIONSTORE 커맨드 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드다. 해당하는 일자의 키를 지정하기만 한다면 손쉽게 주간 리더보드 데이터를 얻을 수 있다.\n22년 8월 15일 ~ 17일까지의 데이터 합산 // \u0026lt;생성할 키 이름\u0026gt;\u0026lt;합산할 키 개수\u0026gt;\u0026lt;합산할 키\u0026gt;... ZUNIONSTORE weekly-score:2208-3 3 daily-score:228015 daily-score:228016 daily-score:228017 합산한 결과 조회 ZRANGE weekly-score:2208-3 0 -1 withscores ZREVRANGE weekly-score:2208-3 0 -1 withscores // 역순정렬 스코어에 가중치 주기 8월 16일에 스코어 두배 이벤트가 있었다면, 두배로 늘려 계산해야한다. // 순서대로 15일, 16일, 17일에 x1, x1, x2의 결과값으로 합산된 랭킹을 구할 수 있다. ZUNIONSTORE weekly-score:2208-03 3 daily-score:228015 daily-score:228016 daily-score:228017 weights 1 1 2 sorted set을 이용한 최근 검색 내역\n유저 별로 다른 키워드 노출 검색 내역은 중복 제거 가장 최근 검색한 5개의 키워드만 사용자에게 노출 sorted set은 중복을 허용하지 않으며, 스코어를 시간으로 사용한다면 최근 검색 기록을 정렬할 수 있다. 데이터를 저장할때 유저가 검색한 시간을 스코어로 저장한다면 검색 시간 순으로 정렬된 데이터가 저장된다.\n▶ user id가 123인 유저의 검색 기록 저장\nZADD search-keyword:123 20221106143501 코듀로이 ZADD search-keyword:123 20221105220913 실버 ZADD search-keyword:123 20221105221002 반지갑 ZADD search-keyword:123 20221105220954 에나멜 ZADD search-keyword:123 20221106152734 기모후드 ▶ 최근 데이터 조회\nZREVRANGE search-keyword:123 0 4 withscores ▶ 반지갑이라는 키워드 재검색\nZADD search-keyword:123 20221106160104 반지갑 ▶ 오래된 데이터 삭제 sorted set의 음수 인덱스를 사용해서 데이터를 삭제한다면, 아이템의 개수(6개가 되었는지)를 확인해야하는 번거로운 작업을 줄일 수 있다. 음수 인덱스는 아이템의 제일 마지막 값을 -1로 시작해서 역순으로 증가하는 값이다. ex) 데이터가 6개라면, 인덱스 0 또는 음수인덱스 -6이 제일 오래된 아이템이다.\n6번째 데이터를 삽입한다. ZADD search-keyword:123 20221106165302 버킷햇 전체 데이터를 조회한다. ZREVRANGE search-keyword:123 0 -1 withscores 0번째 인덱스 또는 -6 인덱스인 \u0026lsquo;실버\u0026rsquo;를 삭제한다. ZREMRANGEBYRANK search-keyword:123 -6 -6 // -6부터 -6까지 만약 아이템의 개수가 5개보다 많지 않을때에는 -6번째 인덱스는 존재하지 않기 때문에 삭제된 데이터가 없으므로 영향을 주지 않는다. 이로써 굳이 아이템의 개수를 체크할 필요없이 최근 데이터 5개만 유지할 수 있다.\nsorted set을 이용한 태그 기능 ▶ 각 포스트가 사용하는 태그를 레디스의 set을 이용해 저장해보자. 태그는 IT, REDIS, DataStore 이라고 하자.\nSADD post:47:tags IT REDIS DataStore SADD post:22:tags IT python 태그 기능을 사용하는 이유는 특정 게시물이 어떤 태그와 연관돼 있는지 확인하기 위함과, 특정한 태그를 포함한 게시물들만 확인하기 위해서다.\n▶ 태그를 기준으로 하는 set에 각각 데이터를 넣어보자.\nSADD tag:DataStore:posts 53 SADD tag:IT:posts 53 SADD tag:MySQL:posts 53 ▶ SMEMBERS 커맨드 특정 태그를 갖고있는 포스트를 쉽게 확인할 수 있다.\nSMEMBERS tag:IT:posts ▶ SINTER 커맨드 IT, DataStore 태그를 모두 포함하는 게시물을 확인하고 싶은 경우 set의 교집합을 구하면된다.\nSINTER tag:IT:posts tag:DataStore:posts 좋아요 처리하기 # 댓글 id를 기준으로 set을 생성한뒤, 좋아요를 누른 유저의 id를 저장하면 중복 없이 데이터를 저장할 수 있다.\n좋아요를 누른 유저 967 저장 SADD comment-like:12554 967 건수 조회 SCARD comment-like:12554 hash를 이용한 읽지 않은 메시지 수 카운팅하기 # 채널에 새로 추가된 메시지의 개수를 확인하면 된다. 사용자의 ID를 키로 사용하고, 채널의 ID를 아이템의 키로 활용해 숫자 형태의 메시지 카운트를 관리한다.\nID가 234인 사용자 -\u0026gt; 4234 채널에서 새로운 메시지를 수신 HINCRBY user:234 channel:4234 1 전송한 메시지를 삭제했다면 데이터 감소 HINCRBY user:234 channel:4234 -1 DAU 구하기 # DAU(Daily Active User)는 하루 동안 서비스에 방문한 사용자의 수를 의미한다. 하루에 여러번 방문했다 하더라도 한번으로 카운팅되는 값으로, 실제 서비스를 이용한 사용자의 유니크한 수를 파악할 수 있는 지표다.\n레디스의 비트맵을 이용하면 메모리를 효율적으로 줄이면서도 실시간으로 서비스의 DAU를 확인할 수 있다. 사용자 ID는 string 자료구조에서 하나의 비트로 표현될 수 있다.\n2022년 11월 6일에 방문한 유저 id를 구한다. uv:20221106 데이터를 만든 뒤, 접속한 유저 id의 bit를 1로 설정한다. id가 14인 유저가 접근했을때 오프셋 14를 1로 설정해준다. SETBIT uv:20221106 14 1 유저 수 확인 BITCOUNT uv:20221106 ▶ BITOP AND 커맨드 출석 이벤트를 진행하기 위해 특정 기간 11월 1일부터 11월 3일까지 매일 방문한 사용자를 구해보자.\n// 11월 1일 ~ 11월 3일 BITOP AND event:202211 uv:20221101 uv:20221102 uv:20221103 ▶ 위 이벤트 결과 확인\nGET event:202211 "},{"id":32,"href":"/docs/redis/002_redis_cache/","title":"002 Redis Cache","section":"Redis","content":" 레디스를 캐시로 사용하기 # [캐시란?] # 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소를 의미한다.\n[캐시로서의 레디스] # 레디스는 자체적으로 고가용성 기능을 가지고있다. 일부 캐싱 전략에서는 캐시에 접근할 수 없게 되면 이는 곧바로 서비스 장애로 이어질 수 있따. 캐시 저장소도 일반적인 데이터 저장소와 같이 안정적으로 운영될 수 있는 조건을 갖추는 것이 좋다. 레디스의 센티널, 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버(Failover; 장애대비)를 발생시키기 때문에, 운영자의 개입 없이 캐시는 정상으로 유지될 수 있어 가용성이 높아진다. 레디스의 클러스터를 사용하면 캐시의 스케일 아웃 또한 쉽게 처리 가능하다. 서비스 규모에 따라 캐시 자체의 규모도 늘어나야할 상황이 발생할 수 있는데, 자체 샤딩 솔루션인 클러스터를 사용하면 수평 확장이 간단해진다. 레디스는 캐시 저장소 용도로 이상적이다.\n[캐싱 전략] # 캐싱 전략은 캐싱되는 데이터의 유형과 데이터에 대한 엑세스 패턴에 따라 다르기 때문에 적절한 캐싱 전략을 선택해야한다.\n[읽기 전략 - look aside] # 애플리케이션에서 데이터를 읽어갈때 주로 사용한다. 레디스를 사용할때 가장 일반적으로 배치하는 방법이다.\n데이터가 먼저 캐시에 있는지 확인한다. 캐시에 있으면 캐시에서 데이터를 읽어온다. (=캐시 히트) 찾고자하는 데이터가 없을때에는 캐시 미스가 발생하며, 직접 데이터베이스에 접근해 찾고자하는 데이터를 가져온다. 찾고하자는 데이터가 레디스에 없을때에만 레디스에 저장하므로 lazy loading 이라고도 부른다. 장점\n레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생하더라도 장애 발생이 아닌, 직접 데이터베이스에 다시 데이터를 가지고온다. 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많으 부하를 발생시킬 수 있다. 미리 데이터베이스에서 캐시로 데이터를 밀어넣어주는 작업을 하기도하는데, 이를 캐시 워밍(cache warming)이라고도 한다.\n[쓰기 전략과 데이터의 일관성] # 캐시 불일치 : 데이터가 변경될때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않을때 발생하는 데이터 불일치\n[쓰기 전략 - writh throwgh] # 데이터베이스에 업데이트할때마다 매번 캐시에도 데이터를 함께 업데이트시키는 방식이다. 캐시는 항상 최신 데이터를 가지고있을 수 있다. 데이터는 매번 2개의 저장소에 저장돼야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다.\n다시 사용될만한 데이터가 아닌 경우에는? 무조건 캐시에도 저장되는건 리소스 낭비일 수도 있다. 따라서 위 방시을 사용할 경우 데이터를 저장할때 만료 시간을 사용할 것을 권장한다.\n[cache invalidation] # 데이터베이스에 값을 업데이트 할때마다 캐시에는 데이터를 삭제한다. 신규 데이터 저장보다, 데이터 삭제가 리소스를 훨씬 적게 사용하기 때문이다.\n[write behind(write back)] # 쓰기가 빈번하게 발생하는 시스템이라면 이 방식을 고려하자. 데이터베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크I/O를 유말해, 성능 저하가 발생할 수 있다. 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트 한뒤, 이후에는 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트하는 것이다. 저장되는 데이터가 실시간으로 정확한 데이터가 아니어도 되는 경우 유용하다.\n[캐시에서의 데이터 흐름] # 캐시는 메모리이기 때문에 기본적인 스토리지 보다 데이터를 적게 저장할 수 밖에 없다. 캐시는 가득차지 않게 일정 양의 데이터를 유지해야하며 관리되야한다. 캐시로 레디스를 사용할때에는 데이터를 저장함과 동시에 적절한 시간의 TTL 값을 저장하는 것이 좋다.\n[만료시간] # TTL (Time To Live)은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정이다. 만료시간이 설정되면 해당 키와 관련된 데이터는 지정된 시간이 지난 후에 레디스에서 자동으로 삭제된다.\n커맨드 : TTL, EXPIRE(초 단위), PTTL, PEXPIRE (밀리세컨드 단위)\n// 키에 만료시간 지정 SET a 100 EXPIRE a 60 TTL a INCR 커맨드로 데이터를 조작하거나, RENAME을 이용해 키의 이름을 바꾸더라도 만료시간은 그대로 유지된다. 그러나, 기존 키에 새로운 값을 저장해 키를 덮어쓸 때에는 이전에 설정한 마료시간은 유지되지 않고 사라진다.\nSET b 100 EXPIRE b 60 TTL b // 57 SET b banana TTL b // -1 (만료시간이 지정되지 않음) [메모리 관리와 maxmemory-policy 설정] # 레디스의 메모리는 제한적이기 때문에 모든 키에 만료시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득 차는 상황이 발생한다. 메모리의 용량을 초과하는 양의 데이터가 저장되면 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정한다.\nmaxmemory 설정: 데이터의 최대 저장 용량 설정 maxmemory-policy 설정값 : 이 용량을 초과할 때의 처리 방식을 결정하는 설정값\n[Noeviction] # 기본값이다. 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더이상 레디스에 데이터를 저장할 수 없다는 에러를 반환한다.\n[LRU eviction] # LRU(Least-Recently-Used) evicition이란, 레디스에 데이터가 가득 찼을때 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책이다.\nvolatile-lru : 만료 시간이 설정돼있는 키에 한해서 LRU 방식으로 키를 삭제한다. 만약 모든 키에 만료시간이 지정돼있지 않다면, noeviction 상황과 동일하다. allkeys-LRU : 모든 키에 대해 LRU 알고리즘을 사용해서 데이터를 삭제한다. [LFU eviction] # LFU(Least-Frequently-Used) eviction이란, 레디스에 데이터가 가득 찼을때 가장 자주 사용되지 않은 데이터부터 삭제하는 정책이다. 사용 우선순위는 유동적으로 바뀌므로 특정 케이스에서는 LRU보다 더 효울적일 수 있다.\nvolatile-lru : 만료 시간이 설정돼있는 키에 한해서 LFU 방식으로 키를 삭제한다. 만약 모든 키에 만료시간이 지정돼있지 않다면, noeviction 상황과 동일하다. allkeys-LRU : 모든 키에 대해 LFU 알고리즘을 이용해 데이터를 삭제한다. [LANDOM eviction] # 레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다. 랜덤으로 데이터를 삭제하기 때문에 나중에 사용할 수도 있는 데이터를 삭제할 가능성이 높아진다.\nvolatile-random : 만료 시간이 설정돼있는 키에 한해 랜덤하게 키를 삭제한다. allkeys-random : 모든 키에 대해 랜덤하게 키를 삭제한다. [voldatile-ttl] # 만료시간이 가장 작은 키를 삭제한다. 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션이다.\n[캐시 스탬피드 현상] # 대규모 트래픽 환경에서 만료 시간을 어떻게 설정하느냐에 따라 캐시 스탬피드(cache-stampede)와 같은 예상치 못한 문제 상황이 발생할 수 있다. look aside 방식으로 레디스를 사용하고 있을때, 특정 키가 만료되는 시점에 키가 삭제된다면? 여러개의 어플리케이션에서 바라보던 키가 레디스에서 만료돼 삭제된다면 이 서버들은 한꺼번에 데이터베이스에 가서 데이터를 읽어오는 과정을 거친다. 이를 중복 읽기(duplicate read)라고 한다. 이후 각 애플리케이션에서는 읽어온 데이터를 레디스에 쓰게 되는데, 이 또한 여러번 반복되기 때문에 중복 쓰기(duplicate write)가 발생한다.\n[적절한 만료시간 설정] # 캐시 스탬피드를 줄이기 위한 가장 간단한 방법은 만료 시간을 너무 짧지않게 설정하는 것이다. 여러 애플리케이션에서 한꺼번에 접근해야하는 데이터이며, 반복적으로 사용돼야하는 데이터라면 만료시간을 충분히 길게 설정한다.\n[선 계산] # look aside 방식으로 캐시를 사용할때 애플리케이션은 다음 코드와 비슷하게 동작할 것이다. 키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면 여러 애플리케이션에서 한꺼번에 데이터베이스에 접근해 데이터를 읽어오는 과정을 줄여 불필요한 프로세스를 줄일 수 있다.\n[PER 알고리즘] # PER(Probabilistic Early Recomputation) 알고리즘 캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산할 수 있다.\ncurrentTime - ( timeToCompute * beta * log(rand()) ) \u0026gt; expiry currentTime : 현재 남은 만료시간 timeToCompute : 캐시된 값을 다시 계산하는데 걸리는 시간 beta : 기본적으로 1.0 보다 큰 값으로 설정 가능 rand() : 0과 1 사이의 랜덤 값을 반환하는 함수 expiry : 키를 재설정할때 새로 넣어줄 만료 시간 위 알고리즘은 만료시간에 가까워질수록 true를 반환할 확률이 증가하므로, 이는 불필요한 재계산을 효과적으로 방지하는 가장 효율적인 방법일 수 있다.\n[세션 스토어로서의 레디스] # 세션이란? 서비스를 사용하는 클라이언트의 상태 정보를 의미한다. 애플리케이션은 현재 서비스에 로그인돼 있는 클라이언트가 누구인지, 그 클라이언트가 어떤 활동을 하고 있는지 저장하고 있으며, 유저가 서비스를 떠나면 세션스토어에서 유저의 정보를 삭제한다. 많은 서비스에서 레디스를 세션 스토어로 사용하고 있다.\n웹 서버가 여러대로 늘어나는 상황에서, 각 웹 서버별로 세션 스토어를 따로 관리한다면 유저는 유저의 세션 정보를 갖고있는 웹 서버에 종속되야한다. 따라서 레디스를 세션 스토어로 사용해 서버, 데이터베이스와 분리 해놓은 뒤 여러 서버에서 세션 스토어 (1개)를 바라보도록 구성해야한다. 유저는 세션 스토어에 구애받지 않고 어떤 웹 서버에 연결되더라도 동일한 세션 데이터를 조회할 수 있어 트래픽을 효율적으로 분산시킬 수 있으며, 데이터의 일관성도 고려할 필요가 없다. 또한 관계형 데이터베이스보다 훨씬 빠르고 접근하기도 간편하므로 데이터를 가볍게 저장할 수 있다.\n레디스의 hash 자료구조는 세션 데이터를 저장하기에 알맞은 형태다.\nHMSET usersession:1 Name Garimoo IP 10:20:104:30 Hits 1 HINCRBY userssession:2 Hits 1 [캐시와 세션의 차이] # 레디스를 캐시로 사용할때에의 가장 일반적인 look aside 전략을 이용할때 데이터는 데이터베이스의 서브셋으로 동작한다. 세션 스토어에 저장된 데이터는 여러 사용자간 공유되지 않으며, 특정 사용자 ID에 한해 유효하다. 일반적인 세션 스토어에서는 유저가 로그인하면 세션 데이터는 세션 스토어에 저장된다. 유저가 로그인해 있는 동안, 즉 세션이 활성화돼 있는 동안에는 애플리케이션은 유저의 데이터를 데이터베이스가 아닌 세션 스토어에만 저장한다.\n"},{"id":33,"href":"/docs/kotlin/002_Functional_Programming_Example/","title":"002 Functional Programming Example","section":"Kotlin","content":" 코틀린으로 함수형 프로그래밍 시작하기 # [고차함수 : 함수를 함수에 넘기기] # 함수형 프로그램을 작성할때 기본이 되는 몇가지 주제\n함수도 값이다. 함수를 변수에 대입하거나 데이터 구조에 저장하거나 함수의 인자로 넘길 수 있다. 고차함수란? 다른 함수를 인자로 받는 함수\n고차함수 예제 어떤 수의 절댓값과 다른 수의 계승(팩토리얼; factorial)을 출력하는 프로그램\n루프를 함수적으로 작성하는 방법 n의 계승을 계산하는 함수를 추가한다. 재귀(recursion)를 통해 순수 함수로 루프를 작성할 수 있다. fun factorial(i: Int): Int { fun go(n: Int, acc: Int): Int = // \u0026lt;1\u0026gt; if (n \u0026lt;= 0) acc // 루프를 종료시키려면 재귀 호출을 하지 않고, 값을 반환한다. else go(n - 1, n * acc) // 재귀 호출 return go(i, 1) // \u0026lt;2\u0026gt; } i=1 go(0, 1x1) i=2 go(1, 2x1) i=3 go(2, 3x2) i=4 go(3, 4x6) i=5 go(4, 5x24)\n코틀린은 이런 식의(루프로 표현할 수 있는) 재귀를 수동으로 감지하지는 않지만 함수 앞에 tailrec 변경자를 붙이도록 요구한다. tailrec이 붙은 경우 컴파일러는 재귀 호출이 꼬리 위치(tail position)인 경우에 한해 while 루프로 작성했을 때와 같은 종류의 바이트 코드를 토해낸다. =\u0026gt; \u0026ldquo;꼬리 위치에 있는 재귀 호출을 최적화해 while 루프 형태로 변환한다.\u0026rdquo;\n코틀린의 꼬리 호출 fun factorial(i: Int): Int { tailrec fun go(n: Int, acc: Int): Int = // \u0026lt;1\u0026gt; if (n \u0026lt;= 0) acc else go(n - 1, n * acc) // \u0026lt;2\u0026gt; return go(i, 1) } 재귀적인 함수 호출을 하는 호출자가 재귀 함수 호출이 반환값을 즉시 호출하기만 하고 다른 아무일도 하지 않을때, 재귀 호출이 꼬리 위치에 있다고 말한다.\n꼬리 위치에 있다 : go(n-1, n*acc) 꼬리 위치에 있지 않다 : 1 + go(n-1, n*acc) 어떤 함수의 모든 재귀 호출이 꼬리 위치에 있고 함수 앞에 tailrec 변경자가 붙은 경우 코틀린 컴파일러는 재귀를 이터레이션시 호출 스택을 소비하지 않는 반복적인 루프로 컴파일한다. =\u0026gt; 이는 스택 오버플로우를 방지하고 메모리를 효율적으로 사용하는 데 도움이 된다.\n첫번째 고차함수 작성하기\nobject Example { private fun abs(n: Int): Int = if (n \u0026lt; 0) -n else n private fun factorial(i: Int): Int { //\u0026lt;1\u0026gt; 계층함수(formatFactorial())를 추가했으므로 private로 변경 fun go(n: Int, acc: Int): Int = if (n \u0026lt;= 0) acc else go(n - 1, n * acc) return go(i, 1) } fun formatAbs(x: Int): String { val msg = \u0026#34;The absolute value of %d is %d\u0026#34; return msg.format(x, abs(x)) } fun formatFactorial(x: Int): String { //\u0026lt;2\u0026gt; 새로 추가한 함수 (결과 출력) val msg = \u0026#34;The factorial of %d is %d\u0026#34; return msg.format(x, factorial(x)) } } fun main() { println(Example.formatAbs(-42)) println(Example.formatFactorial(7)) //\u0026lt;3\u0026gt; } 두 함수 formatAbs, formatFactorial은 거의 같다. 이 두 함수를 일반화해서 formatResult() 함수를 만들자.\nfun formatResult(name: String, n: Int, f: (Int) -\u0026gt; Int): String { val msg = \u0026#34;The %s of %d is %d.\u0026#34; return msg.format(name, n, f(n)) } fun main() { println(formatResult(\u0026#34;factorial\u0026#34;, 7, ::factorial)) println(formatResult(\u0026#34;absolute value\u0026#34;, -42, ::abs)) } 고차함수\nfun formatResult(name: String, n: Int, f: (Int) -\u0026gt; Int): String { ... } f에 대해서도 타입을 지정한다. f가 정수를 인자로 받고 정수를 반환하는 함수라는 뜻이다.\nabs()나 factorial()을 formatResult의 f 인자로 넘길 수 있다.\nprintln(formatResult(\u0026#34;factorial\u0026#34;, 7, ::factorial)) println(formatResult(\u0026#34;absolute value\u0026#34;, -42, ::abs)) [다형적 함수 : 타입에 대해 추상화하기] # 다형적(polymorphic) 함수 : 고차 함수를 작성할때 어떤 타입이 주어지든 관계없이 동작하는 코드\n예제\n배열에서 어떤 문자열을 찾는 단형적 함수 fun findFirst(ss: Array\u0026lt;String\u0026gt;, key: String): Int { tailrec fun loop(n: Int): Int = when { n \u0026gt;= ss.size -\u0026gt; -1 // \u0026lt;1\u0026gt; ss[n] == key -\u0026gt; n // \u0026lt;2\u0026gt; else -\u0026gt; loop(n + 1) // \u0026lt;3\u0026gt; } return loop(0) // \u0026lt;4\u0026gt; } 위 1)번의 단형적 함수를 다형적 함수로 변환 술어 함수(predicate function)는 어떤 조건을 평가하여 참(true) 또는 거짓(false) 중 하나를 반환하는 함수 fun \u0026lt;A\u0026gt; findFirst(xs: Array\u0026lt;A\u0026gt;, p: (A) -\u0026gt; Boolean): Int { // \u0026lt;1\u0026gt; 원소 타입이 A인 배열에 작용, 배열의 각 원소에 작용하는 술어 함수를 파라미터로 받음 tailrec fun loop(n: Int): Int = when { n \u0026gt;= xs.size -\u0026gt; -1 p(xs[n]) -\u0026gt; n // \u0026lt;2\u0026gt; 술어 함수를 배열 원소에 적용하기 else -\u0026gt; loop(n + 1) } return loop(0) } 타입 변수 A를 사용하는 위치\n배열의 원소는 모두 A 타입이어야 한다. xs: Array\u0026lt;A\u0026gt; p 함수는 A 타입의 값을 인자로 받는다. p: (A) -\u0026gt; Boolean 두 위치에서 같은 타입 변수를 참조한다는 사실은 findFirst()의 두 인자에서 해당 타입이 같은 타입이어야만 한다는 사실을 암시한다. 컴파일러는 findFirst()를 호출하는 코드가 이 두 부분에서 같은 타입을 사용하도록 강제한다.\n[익명 함수를 사용해 고차함수 호출하기] # \u0026gt;\u0026gt;\u0026gt; findFirst(arrayOf(7, 9, 13), {i: Int -\u0026gt; i == 9} {i: Int -\u0026gt; i == 9} 라는 구문을 함수 리터럴이나 익명 함수라고 한다.\n[타입에 맞춰 구현하기] # 함수 시그니처에 의해 구현이 하나로 정해지는 예제를 살펴보자.\nfun \u0026lt;A, B, C\u0026gt; partial1(a: A, f: (A, B) -\u0026gt; C): (B) -\u0026gt; C = TODO() 부분 적용(partial application)을 수행하는 고차함수다. partial1() 함수는 어떤 값과 함수(인자를 둘 받아서, 다른 결과를 내놓음)를 인자로 받는다. 인자를 하나만 받아서 결과를 내놓는 함수를 반환한다. 고차함수 f: (A, B) -\u0026gt; C 반환타입 우리가 반환해야하는 대상의 타입이다. (B) -\u0026gt; C 인자 타입이 B인 함수 리터럴을 작성한다. partial1()의 본문 안에서 a값을 자유롭게 사용할 수 있다. 마찬가지로 b도 익명함수의 인자이므로 함수 본문에서 자유롭게 사용할 수 있다. fun \u0026lt;A, B, C\u0026gt; partial1(a: A, f: (A, B) -\u0026gt; C): (B) -\u0026gt; C = { b: B -\u0026gt; TODO() } 내부 함수가 C 타입의 값을 반환해야한다. C타입의 값을 어떻게 얻을까? C 타입 값은 f 고차함수의 결괏값이다. 따라서 C 타입 값을 얻는 유일한 방법은 f 함수에 A, B 타입 값을 넘기는 것뿐이다. fun \u0026lt;A, B, C\u0026gt; partial1(a: A, f: (A, B) -\u0026gt; C): (B) -\u0026gt; C = { b: B -\u0026gt; f(a, b) } 결과적으로 인자 2개를 받아서 부분적으로 적용해 돌려주는 고차함수가 생긴 것이다. =\u0026gt; \u0026ldquo;A 그리고 A, B를 인자로 받아서 C를 생성해주는 함수가 있다면, A는 이미 인자에 있기 때문에 B만 제공한다면 C를 돌려주는 새로운 함수를 만들 수 있다.\u0026rdquo; 코틀린의 타입 추론 특성으로, 타입 애너테이션 생략이 가능하다. fun \u0026lt;A, B, C\u0026gt; partial1(a: A, f: (A, B) -\u0026gt; C): (B) -\u0026gt; C = { b -\u0026gt; f(a, b) } // 여기서 타입 생략 "},{"id":34,"href":"/docs/kotlin/001_Functional_Programming/","title":"001 Functional Programming","section":"Kotlin","content":" 함수형 프로그래밍이란? # 명령어 스타일 (imperative style) # 컴퓨터에게 정해진 명령 또는 지시를 하나하나 내림으로써 각 명령 단계마다 시스템의 상태를 바꾼다. 처음에는 단순화하려는 의도나, 시스템이 커질수록 복잡해지며, 그 결과 코드를 더이상 유지보수할 수 없게 되고, 테스트 하기 어려워지며 코드를 추론하는데에 어려워진다. 함수형 프로그래밍 (FP, Functional Programming) # 위 명령어 스타일의 대안으로, \u0026lsquo;부수 효과\u0026rsquo;를 완전히 없애는 개념이다. 함수형 프로그래밍의 전제는, 순수 함수를 통해 프로그램을 구성한다는 것이다. 순수 함수 : 아무 부수 효과가 없는 함수 부수 효과란? 결과를 반환하는 것 외에 무언가 다른 일을 하는 함수는 부수 효과가 있는 함수다. 변경이 일어나는 블록 외부 영역에 있는 변수를 변경한다. 데이터 구조를 인플레이스로 변경한다. (즉, 메모리의 내용을 직접 변경한다.) 객체의 필드를 설정한다. 예외를 던지거나 예외를 발생시키면서 프로그램을 중단시킨다. 콘솔에 출력을 하거나 사용자 입력을 읽는다. 파일을 읽거나 쓴다. 화면에 무언가를 그린다. 함수형 프로그래밍(FP)의 장점 : 예제로 알아보기 # 부수 효과가 있는 프로그램 순수하지 않은 프로그램 val listing1 = { class CreditCard { fun charge(price: Float): Unit = TODO() } data class Coffee(val price: Float = 2.50F) //tag::init1[] class Cafe { fun buyCoffee(cc: CreditCard): Coffee { val cup = Coffee() // \u0026lt;1\u0026gt; cc.charge(cup.price) // \u0026lt;2\u0026gt; return cup // \u0026lt;3\u0026gt; } } CreditCard 객체의 charge() 메서드를 호출한다. 이로써 부수 효과가 생긴다. 신용카드를 청구하려면, 신용 카드사에 요청해야하므로 외부에서 부수적으로 벌어지는 일이다. 반환하는 객체는 단지 Coffee 객체다. 이 부수효과로 인해서, 테스트가 어려워진다. 실제 신용 카드사에 접속해서 요청하는 것은 원하지 않는다. CreditCard는 신용카드사에 접속해 비용을 청구하는 방법을 알아서는 안된다. CreditCard가 이런 관심사를 알지 못하게 하고, buyCoffee에 Payments 객체를 넘김으로써 이 코드를 좀더 모듈화하고 테스트성을 향상시킬 수 있다. val listing2 = { data class Coffee(val price: Float = 2.95F) class CreditCard class Payments { fun charge(cc: CreditCard, price: Float): Unit = TODO() } //tag::init2[] class Cafe { fun buyCoffee(cc: CreditCard, p: Payments): Coffee { val cup = Coffee() p.charge(cc, cup.price) return cup } } //end::init2[] } Payments를 인터페이스로 선언할 수 있고, 이 인터페이스에에 대해 테스트에 적합한 mock 객체를 구현할 수 있다. 불필요하게 Payments를 인터페이스로 선언해야한다. buyCoffee()를 재사용하기가 어렵다. 한 고객이 커피를 12잔 주문할 경우, for문으로 buyCoffee()를 호출할 것이다. 이런 식으로 호출하면 charge() 메서드가 12번 수행되어 신용카드사에 12번 연결해서 청구라는 행위를 수행하게 된다. 위 문제의 처리 방안으로, buyCoffess()라는 새로운 함수를 작성해서 한꺼번에 청구하는 로직을 넣을 수 있다. 함수형 해법 # 부수 효과를 제거하고 buyCoffee가 Coffee와 함께 청구할 금액을 반환하게하자. val listing3 = { class CreditCard data class Coffee(val price: Float = 2.50F) data class Charge(val cc: CreditCard, val amount: Float) //tag::init3[] class Cafe { fun buyCoffee(cc: CreditCard): Pair\u0026lt;Coffee, Charge\u0026gt; { val cup = Coffee() return Pair(cup, Charge(cc, cup.price)) // 어떤 금액 청구를 만드는 관심사(Coffee), 청구를 처리하거나 해석하는 관심사(Charge) } } } 두 관심사로 분리했다. 어떤 금액 청구를 만드는 관심사 = Coffee 청구를 처리하거나 해석하는 관심사 = Charge Charge CreditCard와 amount를 포함한다. 같은 CreditCard에 대한 청구를 하나로 묶어줄때 편리하게 쓸 수 있는 combine 함수를 제공한다. val listing4 = { class CreditCard //tag::init4[] data class Charge(val cc: CreditCard, val amount: Float) { // \u0026lt;1\u0026gt; 생성자와 불변 필드가 있는 데이터 클래스 선언 fun combine(other: Charge): Charge = // \u0026lt;2\u0026gt;같은 신용카드에 대한 청구를 하나로 묶음 if (cc == other.cc) // \u0026lt;3\u0026gt; 같은 카드인지 검사. 그 외의 경우 에러 발생 Charge(cc, amount + other.amount) // \u0026lt;4\u0026gt; 이 Charge와 다른 Charge의 금액을 합산한 새로운 Charge를 반환 else throw Exception( \u0026#34;Cannot combine charges to different cards\u0026#34; ) } } buyCoffees 생성 # 이제는 우리 바람대로 buyCoffee를 바탕으로 이 함수를 구현할 수 있다. val listing5 = { class CreditCard data class Coffee(val price: Float = 2.50F) data class Charge(val cc: CreditCard, val amount: Float) { fun combine(other: Charge): Charge = TODO() } //tag::init5[] class Cafe { fun buyCoffee(cc: CreditCard): Pair\u0026lt;Coffee, Charge\u0026gt; = TODO() fun buyCoffees( cc: CreditCard, n: Int // 구매할 커피잔 수 ): Pair\u0026lt;List\u0026lt;Coffee\u0026gt;, Charge\u0026gt; { val purchases: List\u0026lt;Pair\u0026lt;Coffee, Charge\u0026gt;\u0026gt; = List(n) { buyCoffee(cc) } // \u0026lt;1\u0026gt; 자체적으로 초기화되는 리스트를 생성한다. val (coffees, charges) = purchases.unzip() // \u0026lt;2\u0026gt; Pair의 리스트를 두 리스트로 분리한다. List\u0026lt;Coffee\u0026gt;, List\u0026lt;Charge\u0026gt; return Pair( coffees, charges.reduce { c1, c2 -\u0026gt; c1.combine(c2) } ) // \u0026lt;3\u0026gt; coffees를 한 Charge로 합친 출력을 생성한다. } } } 이제는 buyCoffees 함수를 정의할때 직접 buyCoffee를 재사용할 수 있다. Payments 인터페이스에 대한 복잡한 mock 구현을 정의하지 않아도 이 두 함수를 아주 쉽게 테스트할 수 있다. Cafe 객체는 이제 Charge 값이 어떻게 처리되는지와는 무관하다. 같은 카드에 청구하는 금액을 모두 합치기 # val listing6 = { class CreditCard data class Charge(val cc: CreditCard, val amount: Float) { fun combine(other: Charge): Charge = TODO() } //tag::init6[] fun List\u0026lt;Charge\u0026gt;.coalesce(): List\u0026lt;Charge\u0026gt; = this.groupBy { it.cc }.values .map { it.reduce { a, b -\u0026gt; a.combine(b) } } } 청구 금액의 리스트를 취해서 사용한 신용카드에 따라 그룹으로 나누고, 각 그룹의 청구 금액을 하나로 합쳐서 카드마다 하나씩 청구로 만들어낸다. 순수 함수란? # 어떤 함수가 주어진 입력으로부터 결과를 계산하는 것 외에 다른 어떤 관찰 가능한 효과가 없다 -\u0026gt; \u0026ldquo;부수효과가 없다\u0026rdquo; \u0026ldquo;부수 효과가 없는 함수\u0026rdquo; -\u0026gt; \u0026ldquo;순수 함수\u0026rdquo; ex) String의 length 함수 : 주어진 문자열에 대해 항상 같은 길이가 반환되며, 다른 일은 발생하지 않는다. 참조 투명성(RT, Referential Transparency)이라는 개념을 사용해 형식화할 수 있다. 예시로 이해하자. 2 + 3은 순수함수 plus(2, 3)에 적용하는 식이다. 이 식에는 아무 부수효과가 없다. 결과는 언제나 5다. 실제로 프로그램에서 2 + 3을 볼때마다 이 식을 5로 치환할 수 있다. 이렇게 해도 프로그램의 의미가 전혀 바뀌지 않는다. 이는 어떤 식이 참조 투명하다는 말이 지닌 뜻의 전부다. 어떤 프로그램에서 프로그램의 의미를 변경하지 않으면서 식을 그 결괏값으로 치환할 수 있다면, 이 식은 참조 투명하다. 어떤 함수를 참조 투명한 인자를 사용해 호출한 결과가 참조 투명하다면 이 함수도 참조 투명하다. 참조 투명성 예제 # class CreditCard { fun charge(price: Float): Unit = TODO() } data class Coffee(val price: Float = 2.50F) //tag::init[] fun buyCoffee(cc: CreditCard): Coffee { val cup = Coffee() cc.charge(cup.price) return cup } buyCoffee()는 cc.charge(cup.price)의 반환 타입과 관계없이 이 함수 호출의 반환값을 무시한다. 따라서 buyCoffee()를 평과한 결과는 그냥 cup이고, 이 값은 Coffee()와 동일하다. 순수 함수가 되기 위해서는 p에 관계없이 p(buyCoffee(aliceCreditCard)), p(Coffee())가 똑같이 작동해야한다. 성립되지 않는다. p(buyCoffee(aliceCreditCard)) : 카드사를 통해 커피 값을 청구한다. p(Coffee()) : 아무일도 하지 않는다. 참조 투명성 예제(2) # \u0026gt;\u0026gt;\u0026gt; val x = \u0026#34;Hello, World\u0026#34; \u0026gt;\u0026gt;\u0026gt; val r1 = x.reversed() \u0026gt;\u0026gt;\u0026gt; val r2 = x.reversed() x가 등장하는 부분을 x가 가리키는 식으로 바꿔치기 하면 다음과 같다. \u0026gt;\u0026gt;\u0026gt; val r1 = \u0026#34;Hello, World\u0026#34;.reversed() \u0026gt;\u0026gt;\u0026gt; val r2 = \u0026#34;Hello, World\u0026#34;.reversed() 위 r1, r2가 같은 값으로 평가된다. x가 참조 투명하기 때문에 r1, r2 값은 예전과 같다. -\u0026gt; r1, r2도 참조 투명하다. 참조 투명성을 위배하는 예제 # \u0026gt;\u0026gt;\u0026gt; val x = StringBuilder(\u0026#34;Hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; val y = x.append(\u0026#34;, World\u0026#34;) \u0026gt;\u0026gt;\u0026gt; val r1 = y.toString() \u0026gt;\u0026gt;\u0026gt; val r2 = y.toString() append() 함수 : StringBuilder에 작용하며 객체 내부를 변화시킨다. append()가 호출될 때마다 StringBuilder의 이전 상태가 파괴된다. StringBuilder에 대해 toString()을 여러번 호출해도 항상 똑같은 결과를 얻는다. \u0026gt;\u0026gt;\u0026gt; val x = StringBuilder(\u0026#34;Hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; val r1 = x.append(\u0026#34;, World\u0026#34;).toString() \u0026gt;\u0026gt;\u0026gt; val r2 = x.append(\u0026#34;, World\u0026#34;).toString() y를 모두 append() 호출로 치환했다. -\u0026gt; 순수 함수가 아니라고 결론을 내릴 수 있다. StringBuilder에 대해 toString()을 여러번 호출해도 결코 같은 결과가 생기지 않는다. r1, r2는 같은 식처럼 보이지만, 실제로는 같은 StringBuilder 객체의 다른 두 값을 가르킨다. "},{"id":35,"href":"/docs/reactive-streams/001_reactive_streams_component/","title":"001 Reactive Streams Component","section":"Reactive Streams","content":" 리액티브 스트림즈란? # 리액티브한 코드 작성을 위한 구성을 도와주는 리액티브 라이브러리가 있다. 이 리액티브 라이브러리를 어떻게 구현해야할지 정의해놓은 별도의 표준 사양을 리액티브 스트림즈(Reactive Streams)라고 한다.\n리액티브 스트림즈는 \u0026lsquo;데이터 스트림을 Non-Blocking이면서 비동기적인 방식으로 처리하기 위한 리액티브 라이브러리 표준 사양\u0026rsquo;이라고 표현할 수 있다. 이를 구현한 구현체로는 RxJava, Reactor, Akka Streams, Java 9 Flow API 등이 있고, 그 중에 Spring framework와 가장 궁합이 잘 맞는 구현체는 Reactor이다.\n리액티브 구성요소 # 리액티브 스트림즈를 통해 구현해야 되는 API 컴포넌트에는 Publisher, Subscriber, Subscription, Processor 가 있다. 이 4개의 컴포넌트를 반드시 기억해야한다. 아무래도 이 4개의 역할이 헷갈리면 전체적인 동작과정까지도 헷갈리게되기 때문에 확실히 짚고 넘어가자.\n컴포넌트 설명 Publisher 데이터를 생성하고 통지(발행, 게시, 방출)하는 역할을 한다. Subsriber 구독한 Publisher로부터 통지된 데이터를 전달받아서 처리한다. Subscription Publisher에 요청할 데이터의 개수를 지정하고, 데이터의 구독을 취소하는 역할을 한다. Processor Publisher와 Subscriber의 기능을 모두 가지고 있다. 즉, Subscriber로서 다른 Publisher를 구독할 수 있고, Publisher로서 다른 Subscriber가 구독할 수 있다. Publisher와 Subscriber의 동작과정을 나타내는 그림 # 1. 데이터를 구독한다. (subscribe)\n먼저 Subscriber는 전달받을 데이터를 구독한다.\n2. 데이터를 통지할 준비가 되었음을 알린다. (onSubscribe)\nPublisher는 데이터를 통지할 준비가 되었음을 Subscriber에 알린다.\n3. 전달 받을 통지 데이터 개수를 요청한다. (Subscription.request)\nPublisher가 데이터를 통지할 준비가 되었다는 알림을 받은 Subscriber는 전달받기를 원하는 데이터의 개수를 Publisher에게 요청한다.\n▶ 데이터의 요청 개수를 지정하는 이유가 뭘까?\nSubscriber가 Subscription.reuqest를 통해 데이터의 요청 개수를 지정한다. 이는 실제로 Publisher와 Subscriber는 각각 다른 스레드에서 비동기적으로 상호작용하는 경우가 대부분이기 때문이다.\n이럴 경우 Publisher가 통지하는 속도가 Publisher로부터 통지된 데이터를 처리하는 Subscriber가 처리하는 속도보다 더 빠르면 처리를 기다리는 데이터가 쌓이게되어 시스템 부하가 커질 수 있다. 이러한 결과를 방지하기 위한 행위다.\nPublisher의 데이터 통지 속도 \u0026gt; 통지된 데이터를 처리하는 Subscriber 속도 간단하게 생각해보면 데이터가 전송되는 속도가 데이터가 처리되는 속도보다 빠르면 계속해서 처리해야하는 데이터가 밀리기 때문인 것이다.\n4. 데이터를 생성한다.\n5. 요청 받은 개수만큼 데이터를 통지한다. (onNext)\nPublisher는 Subscriber로부터 요청받은 만큼의 데이터를 통지한다.\n6. 데이터 처리를 완료할때까지 위 3~5번의 과정을 반복한다.\n이렇게 Publisehr와 Subscriber 간에 데이터 통지, 데이터 수신, 데이터 요청의 과정을 반복한다.\n7. 완료 또는 에러가(onError) 발생할때까지 데이터 생성, 통지, 요청을 계속한다.\n8. 데이터 통지가 완료되었음을 알린다. (onComplete)\n반복하다가 Publisher가 모든 데이터를 통지하게 되면 마지막으로 데이터 전송이 완료되었음을 Subscriber에게 알린다. 만약에 Publisher가 데이터를 처리하는 과정에서 에러가 발생하면 에러가 발생했음을 Subscriber에게 알린다.\n위 글의 내용으로 이해가 되지 않아도 계속해서 포스팅을 읽자. 추후에 예제코드를 보고나서 다시 위 글을 읽으면 이해가 될것이다.\n코드로 보는 리액티브 스트림즈 컴포넌트 # 리액티브 스트림즈 컴포넌트의 동작과정을 이미지와 순서 설명으로 알아보았다. 처리 과정은 이해가 되지만 역시나 Publisher, Subscriber, Subscription, Processor의 코드 흐름이 머릿속으로 그려지지는 않는다. 이제 실제 코드를 보면서 조금씩 머릿속으로 그림을 그려보자.\nPublisher.java # public interface Publisher\u0026lt;T\u0026gt; { public void subscribe(Subscriber \u0026lt;? super T\u0026gt; subscriber); } subscribe() 메서드 1개만 존재한다. subscribe() 메서드는 파라미터로 전달받은 Subscriber를 등록하는 역할을 한다.\n\u0026lsquo;Publisher는 데이터를 생성하고 통지하는 역할을 하고, Subscriber는 Publisher가 통지하는 데이터를 전달받기 위해 구독을 한다.\u0026rsquo; 라는 내용으로 봤을때 우리는 구독을 처리하는 subscribe() 메서드가 당연히 Subscriber에 있을거라고 오해할 수 있다. ▶ 왜 Subscriber가 아닌 Publisher에 subscribe() 메서드가 정의되어 있을까?\n리액티브 스트림즈에서의 Publisher/Subscriber는 개념상으로는 Subscriber가 구독을 하는게 맞다. 하지만 실제 코드상으로는 Publisher가 subscribe() 메서드의 파라미터인 Subscriber를 등록하는 형태로 구독이 이뤄진다. 우선 아래의 호출로직으로 Publisher 객체의 subscribe() 메서드를 호출할때 Subscriber 객체를 파라미터로 넘긴다고 이해하자.\n// 구독 pub.subscribe(sub); Subscriber.java # public interface Subscriber\u0026lt;T\u0026gt; { //구독 시작 처리 public void onSubscribe(Subscription subscription); // 아래 Subscription을 인자로 전달 //데이터 통지시 처리 public void onNext(T item); //에러 통지시 처리 public void onError(Throwable error); //완료 통지시 처리 public void onComplete(); } 메서드 설명 onSubscribe 구독 시작 시점에 어떤 처리를 하는 역할을 한다. 여기서의 처리는 Publisher에게 요청할 데이터의 개수를 지정하거나 구독을 해지하는 것을 의미한다. 이것은 onSubscribe 메서드의 파라미터로 전달되는 Subscription 객체를 통해서 이뤄진다. onNext Publisher가 통지한 데이터를 처리하는 역할을 한다. onError Publisher가 데이터를 통지를 위한 처리 과정에서 에러가 발생했을때 해당 에러를 처리하는 역할을 한다. onComplete Publisher가 데이터 통지를 완료했음을 알릴 때 호출되는 메서드다. 데이터 통지가 정상적으로 완료될 경우에 어떤 후처리를 해야한다면 omComplete 메서드에서 처리 코드를 작성하면 된다. Subscripton.java # public interface Subscription { // 통지받을 데이터 개수를 지정해 데이터 통지를 요청하거나 통지받지 않게 구독을 해지할때 사용하는 인터페이스 //통지받을 데이터 개수 요청 public void request(long num); //구독 해지 public void cancel(); // Subscriber에서 호출함 (Subscription을 받은 Subscriber에서 구독 해지를 위해 호출) } 메서드 설명 request Subscriber가 구독한 데이터의 개수를 요청한다. Publisher에게 데이터의 개수를 요청할 수 있다. cancel 구독을 해지한다. 실제 구독하는 구현코드! 위의 설명을 돕기위한 예제 코드다.\n// Publisher Publisher\u0026lt;Integer\u0026gt; pub = new Publisher\u0026lt;Integer\u0026gt;() { @Override public void subscribe(Subscriber\u0026lt;? super Integer\u0026gt; sub) { sub.onSubscribe(new Subscription() { @Override public void request(long n) { ... } @Override public void cancel() { ... } }); } }; // Subscriber Subscriber\u0026lt;Integer\u0026gt; sub = new Subscriber\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Subscription s) { log.debug(\u0026#34;onSubscribe\u0026#34;); s.request(Long.MAX_VALUE); } @Override public void onNext(Integer i) { log.debug(\u0026#34;onNext:{}\u0026#34;, i); } @Override public void onError(Throwable t) { log.debug(\u0026#34;onError:{}\u0026#34;, t); } @Override public void onComplete() { log.debug(\u0026#34;onComplete\u0026#34;); } }; // 구독 pub.subscribe(sub); 결국 Publisher의 subscribe() 메서드를 호출하여 구독하는데, 이때 파라미터 Subscriber 객체를 넘기면 된다.\n위 코드의 흐름\nPublisher와 Subscriber의 동작과정을 리액티브 스트림즈의 컴포넌트 코드 관점에서 다시 이해해보자.\n순서 과정 1 Publisher가 Subscriber 인터페이스 구현 객체를 subscribe 메서드의 파라미터로 전달한다. 2 Publisher 냅에서는 전달받은 Subscriber 인터페이스 구현 객체의 onSubscribe 메서드를 호출하면서 Subscriber의 구독을 의미하는 Subscription 인터페이스 구현 객체를 Subscriber에게 전달한다. 3 호출된 Subscriber 인터페이스 구현 객체의 onSubscribe() 메서드에서 전달받은 Subscription 객체를 통해 전달받을 데이터의 개수를 Publisher 에게 요청한다. 4 Publisher는 Subscriber로부터 전달받은 요청 개수만큼의 데이터를 onNext() 메서드를 호출해서 Subsriber에게 전달한다. 5 Publisher는 통지할 데이터가 더이상 없을 경우 onComplete 메서드를 호출해서 Subscriber에게 데이터 처리 종료를 알린다. Processor.java # public abstract interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publichser\u0026lt;R\u0026gt; {} Processor 인터페이스는 별도로 구현해야할 메서드가 없다. 대신 Subscriber, Publisher 인터페이스를 상속하고있다. 리액티브 스트림즈 컴포넌트에서 설명한대로 Processor가 Publisher과 Subscriber 기능을 모두 가지고있기 때문이다.\n구현 예제코드 # @Slf4j public class E05_PubSub_2 { public static void main(String[] args) { Publisher\u0026lt;Integer\u0026gt; pub = iterPub(Stream.iterate(1, a -\u0026gt; a + 1).limit(10).collect(Collectors.toList())); // 구독자 Subscriber\u0026lt;Integer\u0026gt; sub = logSub(); // 구독 시작 pub.subscribe(sub); } private static Subscriber\u0026lt;Integer\u0026gt; logSub() { Subscriber\u0026lt;Integer\u0026gt; sub = new Subscriber\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Subscription s) { // Subscription 의 request 를 요청해야한다. log.debug(\u0026#34;onSubscribe\u0026#34;); s.request(Long.MAX_VALUE); } @Override public void onNext(Integer i) { log.debug(\u0026#34;onNext:{}\u0026#34;, i); } @Override public void onError(Throwable t) { log.debug(\u0026#34;onError:{}\u0026#34;, t); } @Override public void onComplete() { log.debug(\u0026#34;onComplete\u0026#34;); } }; return sub; } private static Publisher\u0026lt;Integer\u0026gt; iterPub(List\u0026lt;Integer\u0026gt; iter) { Publisher\u0026lt;Integer\u0026gt; pub = new Publisher\u0026lt;Integer\u0026gt;() { // Publisher 의 구현해야하는 메서드 @Override public void subscribe(Subscriber\u0026lt;? super Integer\u0026gt; sub) { // 호출하면 그때부터 데이터를 통지 // Subscription : Publisher, Subscriber 둘 사이의 구독이 한번 일어난다는 의미 sub.onSubscribe(new Subscription() { @Override public void request(long n) { try { // iterable 의 원소를 통지한다. iter.forEach(s -\u0026gt; sub.onNext(s)); // 여기서 멈추면 안되고, publisher 가 데이터 통지가 완료했으면 완료됨을 호출해야한다. sub.onComplete(); } catch (Throwable t) { // 에러 처리 sub.onError(t); } } /** * Subscriber 에서 Subscription 객체의 cancel()을 호출할 수 있다. * 더이상 데이터를 통지받지 않겠다고 알림 */ @Override public void cancel() { } }); } }; return pub; } } Publisher 객체 생성 Publisher\u0026lt;Integer\u0026gt; pub = iterPub(Stream.iterate(1, a -\u0026gt; a + 1).limit(10).collect(Collectors.toList())); Subscriber 객체 생성 Subscriber\u0026lt;Integer\u0026gt; sub = logSub(); 구독 실행! pub.subscribe(sub); 여기서부터 실행 흐름을 들여다보자. # Subscriber 객체의 onSubscribe() 호출 메서드 설명 onSubscribe 구독 시작 시점에 어떤 처리를 하는 역할을 한다. 여기서의 처리는 Publisher에게 요청할 데이터의 개수를 지정하거나 구독을 해지하는 것을 의미한다. 이것은 onSubscribe 메서드의 파라미터로 전달되는 Subscription 객체를 통해서 이뤄진다. Subscriber 객체의 onNext() 호출 메서드 설명 onNext Publisher가 통지한 데이터를 처리하는 역할을 한다. !\n위 1)~2)번 반복\n1, 2, 3 ~ 9까지 반복 완료 후 마지막 데이터인 10의 onNext()가 호출된 시점이 왔다.\n모든 데이터 통지가 완료되었으므로 onComplete() 메서드 호출 메서드 설명 onComplete Publisher가 데이터 통지를 완료했음을 알릴 때 호출되는 메서드다. 데이터 통지가 정상적으로 완료될 경우에 어떤 후처리를 해야한다면 omComplete 메서드에서 처리 코드를 작성하면 된다. ▶ Subscriber 객체의 onComplete() 호출된 모습\n실행결과\n[main] DEBUG com.reactive.step02.E05_PubSub_2 - onSubscribe [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:1 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:2 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:3 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:4 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:5 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:6 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:7 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:8 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:9 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onNext:10 [main] DEBUG com.reactive.step02.E05_PubSub_2 - onComplete "},{"id":36,"href":"/docs/algorithm/000_sample/","title":"000 Sample","section":"Algorithm","content":"sample\n"},{"id":37,"href":"/docs/batch/000_sample/","title":"000 Sample","section":"Batch","content":"sample\n"},{"id":38,"href":"/docs/data-structure/000_sample/","title":"000 Sample","section":"Data Structure","content":"sample\n"},{"id":39,"href":"/docs/ddd/000_sample/","title":"000 Sample","section":"Ddd","content":"sample\n"},{"id":40,"href":"/docs/docker/000_sample/","title":"000 Sample","section":"Docker","content":"sample\n"},{"id":41,"href":"/docs/etc/000_sample/","title":"000 Sample","section":"Etc","content":"sample\n"},{"id":42,"href":"/docs/java/000_sample/","title":"000 Sample","section":"Java","content":"sample\n"},{"id":43,"href":"/docs/jenkins/000_sample/","title":"000 Sample","section":"Jenkins","content":"sample\n"},{"id":44,"href":"/docs/jpa/000_sample/","title":"000 Sample","section":"Jpa","content":"sample\n"},{"id":45,"href":"/docs/kafka/000_sample/","title":"000 Sample","section":"Kafka","content":"sample\n"},{"id":46,"href":"/docs/linux/000_sample/","title":"000 Sample","section":"Linux","content":"sample\n"},{"id":47,"href":"/docs/mongodb/000_sample/","title":"000 Sample","section":"Mongodb","content":"sample\n"},{"id":48,"href":"/docs/msa/000_sample/","title":"000 Sample","section":"Msa","content":"sample\n"},{"id":49,"href":"/docs/mvc/000_sample/","title":"000 Sample","section":"Mvc","content":"sample\n"},{"id":50,"href":"/docs/mysql/000_sample/","title":"000 Sample","section":"Mysql","content":"sample\n"},{"id":51,"href":"/docs/network/000_sample/","title":"000 Sample","section":"Network","content":"sample\n"},{"id":52,"href":"/docs/operating-system/000_sample/","title":"000 Sample","section":"Operating System","content":"sample\n"},{"id":53,"href":"/docs/oracle/000_sample/","title":"000 Sample","section":"Oracle","content":"sample\n"},{"id":54,"href":"/docs/security/000_sample/","title":"000 Sample","section":"Security","content":"sample\n"},{"id":55,"href":"/docs/servlet/000_sample/","title":"000 Sample","section":"Servlet","content":"sample\n"},{"id":56,"href":"/docs/spring/000_sample/","title":"000 Sample","section":"Spring","content":"sample\n"},{"id":57,"href":"/docs/test/000_sample/","title":"000 Sample","section":"Test","content":"sample\n"},{"id":58,"href":"/docs/webflux/000_sample/","title":"000 Sample","section":"Webflux","content":"sample\n"}]